<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>君十一</title>
  
  <subtitle>Stay hungry Stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://junshang11.com/"/>
  <updated>2019-10-08T10:07:04.874Z</updated>
  <id>https://junshang11.com/</id>
  
  <author>
    <name>Jun Shang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文章热度排行系统的实现</title>
    <link href="https://junshang11.com/2019/10/07/%E6%96%87%E7%AB%A0%E7%83%AD%E5%BA%A6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://junshang11.com/2019/10/07/文章热度系统的实现/</id>
    <published>2019-10-06T16:00:00.000Z</published>
    <updated>2019-10-08T10:07:04.874Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个简历项目吧，同时也是为了验证我在15天内自学的SpringBoot和Redis的这两块的知识掌握的怎样。</p><p>灵感的来源是我去年这个时候写区块链项目的时候，需要实现一个搜索框，那时候没学Elastic Search（现在也没学，找完工作立马补上），那时候只会SSM和MySql之类的，除了用模糊查询，我想在我点击搜索框的时候，它能够自动给我提示，大家都在搜什么什么公司，就有点像各类搜索引擎做到的热度排行那样。</p><p>那时候想的是再分一个表出来，因为在公司表后面加一个被搜索的次数，是不符合三范式的，后来随着项目推进，这功能后来就没实现，一是对我们整个的项目影响不大，属于有了更好，没了也不痛不痒的类型。二是因为你想想，这种搜索提示应该是更加实时的，比如说我今天搜的排行和我昨天搜的就不应该一样。那用MySQL做，不会晚上12点drop掉我整个表，然后再记录吧，这种操作是不合理的。</p><p>然后前几天学Redis，学到Zset，一下子就想到了之前那个东西，用Zset正合适。首先Redis是可以设置key的expire time的，然后Zset的score属性能帮助做排序，就可以查出来top 5的是哪几个。所以这边我改一下需求，写一个文章搜索排序系统。</p><p>这篇是一个大的整合，基础的SpringBoot + MyBatis+MySQL+Redis，前端用模版引擎thymeleaf,bootstrap，可能不会很好看，因为时间有限，更多的会注重逻辑层面的。</p><a id="more"></a><h3 id="功能需求是啥"><a href="#功能需求是啥" class="headerlink" title="功能需求是啥"></a>功能需求是啥</h3><p>首先会是一个简单的登陆系统，当用户登陆以后就可以浏览所有的文章list。</p><p>然后点击文章标题进入文章页面，底部有个赞，点击以后，这篇文章的热度会加1。</p><p>右上角有个button“大家都在看”，点击以后就会弹出一个modal框，上面是3小时内，点赞度最高的5篇文章标题。</p><h3 id="一个需要注意的点"><a href="#一个需要注意的点" class="headerlink" title="一个需要注意的点"></a>一个需要注意的点</h3><p>进入系统以后，一个用户对一篇文章只能点赞一次。</p><p>这个我一开始想的有点简单了，假如说我点击了一次以后，文章zset的score加了1了，直接把这个点赞button属性给disable了就行了。但我们很多时候遇到的点赞啊，是可以撤销的。</p><p>所以为了防止误操作，我们还需要一个string类型的redis键，记录这个用户是不是点击过，假如用户再次点击的时候，score -1。</p><p>所以这套系统需要一个zset去记录文章的score，需要一个string去记录用户是否点击过。</p><p>然后我们需要设定这个zset这个key的expire时间，3小时后，也就是10800秒后，这个key就过期了。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个简历项目吧，同时也是为了验证我在15天内自学的SpringBoot和Redis的这两块的知识掌握的怎样。&lt;/p&gt;
&lt;p&gt;灵感的来源是我去年这个时候写区块链项目的时候，需要实现一个搜索框，那时候没学Elastic Search（现在也没学，找完工作立马补上），那时候只会SSM和MySql之类的，除了用模糊查询，我想在我点击搜索框的时候，它能够自动给我提示，大家都在搜什么什么公司，就有点像各类搜索引擎做到的热度排行那样。&lt;/p&gt;
&lt;p&gt;那时候想的是再分一个表出来，因为在公司表后面加一个被搜索的次数，是不符合三范式的，后来随着项目推进，这功能后来就没实现，一是对我们整个的项目影响不大，属于有了更好，没了也不痛不痒的类型。二是因为你想想，这种搜索提示应该是更加实时的，比如说我今天搜的排行和我昨天搜的就不应该一样。那用MySQL做，不会晚上12点drop掉我整个表，然后再记录吧，这种操作是不合理的。&lt;/p&gt;
&lt;p&gt;然后前几天学Redis，学到Zset，一下子就想到了之前那个东西，用Zset正合适。首先Redis是可以设置key的expire time的，然后Zset的score属性能帮助做排序，就可以查出来top 5的是哪几个。所以这边我改一下需求，写一个文章搜索排序系统。&lt;/p&gt;
&lt;p&gt;这篇是一个大的整合，基础的SpringBoot + MyBatis+MySQL+Redis，前端用模版引擎thymeleaf,bootstrap，可能不会很好看，因为时间有限，更多的会注重逻辑层面的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="https://junshang11.com/tags/SpringBoot/"/>
    
      <category term="Redis" scheme="https://junshang11.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot+Redis的应用</title>
    <link href="https://junshang11.com/2019/10/06/SpringBoot+redis/"/>
    <id>https://junshang11.com/2019/10/06/SpringBoot+redis/</id>
    <published>2019-10-05T16:00:00.000Z</published>
    <updated>2019-10-08T08:31:32.469Z</updated>
    
    <content type="html"><![CDATA[<p>今天要整的内容是SpringBoot和Redis的整合应用。这一篇的主要内容是：</p><ol><li><p>使用redisTemplate操作数据</p></li><li><p>用Redis Repository整体操作hash对象</p></li></ol><p>开始吧</p><a id="more"></a><h3 id="使用redisTemplate操作数据"><a href="#使用redisTemplate操作数据" class="headerlink" title="使用redisTemplate操作数据"></a>使用redisTemplate操作数据</h3><p>SpringBoot和Redis的整合还是挺容易的，因为他给我们封装了很棒的redisTemplate模版封装类，想要使用它，第一步，先命令行开启Redis服务端。第二步导包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>SpringBoot 2.0 默认使用的Redis客户端是lettuce，这边引入commons-pool2 是因为lettuce需要commons-pool 2 创建 Redis 连接池。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    database: 0 # Redis 数据库索引（默认为 0）</span><br><span class="line">    host: 127.0.0.1 # Redis 服务器地址</span><br><span class="line">    port: 6379 # Redis 服务器连接端口</span><br><span class="line">    password: ericshang11 # Redis 服务器连接密码（默认为空）</span><br><span class="line">    lettuce:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 8 # 连接池最大连接数（使用负值表示没有限制） 默认 8</span><br><span class="line">        max-wait: -1 # 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1</span><br><span class="line">        max-idle: 8 # 连接池中的最大空闲连接 默认 8</span><br><span class="line">        min-idle: 0 # 连接池中的最小空闲连接 默认 0</span><br></pre></td></tr></table></figure><p>这时候，我们就能拿到redisTemplate。其实spring-boot-starter-data-redis提供了两种模版封装类，这边我使用的是redisTemplate，因为它更加通用，而StringRedisTemplate只能操作list。redisTemplate操作各个数据结构的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue();//操作字符串</span><br><span class="line">redisTemplate.opsForHash();//操作 hash</span><br><span class="line">redisTemplate.opsForList();//操作 list</span><br><span class="line">redisTemplate.opsForSet();//操作 set</span><br><span class="line">redisTemplate.opsForZSet();//操作有序 set</span><br></pre></td></tr></table></figure><p>那如何注入模版类呢，有两种方法。</p><p>一种直接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RedisTemplate&lt;String, String&gt; template;</span><br></pre></td></tr></table></figure><p>另一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Resource(name = &quot;redisTemplate&quot;)</span><br><span class="line">private ValueOperations&lt;String,Object&gt; valueOperations; //操作string</span><br><span class="line">private ListOperations&lt;String, String&gt; listOps; //只操作list</span><br><span class="line">private HashOperations&lt;String, String, Object&gt; hashOperations;//操作hash</span><br><span class="line">private SetOperations&lt;String, Object&gt; setOperations; //操作set</span><br><span class="line">private ZSetOperations&lt;String, Object&gt; zSetOperations; //操作set</span><br></pre></td></tr></table></figure><p>第二种是注入了RedisTemplate的子类。两种都可以。</p><p>我们这边用RedisTemplate去操作一个将一个String类型的元素放入redis中。</p><p>首先创建数据对象，一定要implements Serializable，因为将数据放入redis中，就是一个将对象序列化的过程，所以一定要实现Serializable。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Person implements Serializable &#123;</span><br><span class="line">  String firstname;</span><br><span class="line">  String lastname;</span><br></pre></td></tr></table></figure><p>然后创建一个testcontroller，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class testcontroller &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&quot;/string&quot;)</span><br><span class="line">   public Object testString()&#123;</span><br><span class="line">      Person person = new Person();</span><br><span class="line">      person.setFirstname(&quot;eric&quot;);</span><br><span class="line">      person.setLastname(&quot;shang&quot;);</span><br><span class="line">      redisTemplate.opsForValue().set(&quot;person:1&quot;, person);//放入键为person:1的String类型元素中</span><br><span class="line">      Person getback = (Person) redisTemplate.opsForValue().get(&quot;person:1&quot;);//拿出来</span><br><span class="line">      return getback;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这样，我们用postman测试一下，就可以看到数据成功显示了。</p><p>但这边有两个坑，一个是redis会出现乱码，原因是RedisTemplate默认使用的是JdkSerializationRedisSerializer，它是以二进制形式保存的，而且它比json格式大很多，这时候，我们就需要对他进行配置。将RedisTemplate的序列化方式做一点改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;</span><br><span class="line">        RedisTemplate redisTemplate = new RedisTemplate();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line"></span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">        //重点在这四行代码</span><br><span class="line">        redisTemplate.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以看到乱码消失了。但这边乱码消失了，在redis-cli里，我们看我们的key，value还是会出现乱码，这时候，我们需要这么进入客户端</p><p><code>redis-cli --raw</code></p><p>这样，中文之类的key和value就可以显示了。</p><p>关于RedisTemplate对于不同数据类型提供的方法，这边推荐一个人的博客，整理的很好。<a href="https://blog.csdn.net/weixin_37490221/article/details/78135815" target="_blank" rel="noopener">redisTemplate访问redis数据结构</a></p><h3 id="用Redis-Repository整体操作hash对象"><a href="#用Redis-Repository整体操作hash对象" class="headerlink" title="用Redis Repository整体操作hash对象"></a>用Redis Repository整体操作hash对象</h3><p>因为hash结构是唯一能存放对象的，所以我们在操作hash数据结构的时候，得一个一个添加，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void HashOperations() throws Exception&#123;</span><br><span class="line">       Person person = new Person(&quot;boke&quot;,&quot;byrant&quot;);</span><br><span class="line">       hashOperations.put(&quot;hash:player&quot;,&quot;firstname&quot;,person.getFirstname());</span><br><span class="line">       hashOperations.put(&quot;hash:player&quot;,&quot;lastname&quot;,person.getLastname());</span><br><span class="line">       hashOperations.put(&quot;hash:player&quot;,&quot;address&quot;,person.getAddress());</span><br><span class="line">       System.out.println(hashOperations.get(&quot;hash:player&quot;,&quot;firstname&quot;));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这样的添加方式在元素较多的情况下会显得格外麻烦，所以我们这边学着使用Redis Repository去整体地操作hash对象。</p><p>Repository是spring-data中对于数据库的增删改查的中央存储库。通过它可以对数据库（redis)进行操作。基本的实现为CrudRepository。 那redis通过支持repository，来实现对model在缓存中的增删改查。</p><p>首先我们必须开启支持repository，通过@EnableRedisRepositories，就可以开启redis对repository的支持，通常，我们将@EnableRedisRepositories放在项目入口处，或者将这个放在redis config文件上，这样项目就会自动开启对RedisRepositories的支持。</p><p>然后在数据对象上加上<br><code>@RedisHash("people")</code></p><p>在id属性上加伤@Id</p><p>这连个个的作用是啥呢，给这个对象生成hash数据类型中的key，那这样的话，之后再生成对象的话，redis repository会过来拿这个key。</p><p>之后我们再写一个接口实现CrudRepository</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface PersonRepository extends CrudRepository&lt;Person, String&gt; &#123;</span><br><span class="line"> // 继承CrudRepository，获取基本的CRUD操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放在dao包下。</p><p>之后我们就可以编写代码了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">    PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testHashRep()&#123;</span><br><span class="line">        Person rand = new Person(&quot;eric&quot;, &quot;shang&quot;);</span><br><span class="line">        personRepository.save(rand); //保存进redis</span><br><span class="line">        </span><br><span class="line">        Optional&lt;Person&gt; op = personRepository.findById(rand.getId());//通过key查找元素</span><br><span class="line">        Person p2 = op.get();</span><br><span class="line">      System.out.println(p2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们就可以在控制台看到，元素被读取出来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天要整的内容是SpringBoot和Redis的整合应用。这一篇的主要内容是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用redisTemplate操作数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用Redis Repository整体操作hash对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;开始吧&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="https://junshang11.com/tags/SpringBoot/"/>
    
      <category term="Redis" scheme="https://junshang11.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>redis基础手册</title>
    <link href="https://junshang11.com/2019/10/04/redis%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>https://junshang11.com/2019/10/04/redis学习手册/</id>
    <published>2019-10-03T16:00:00.000Z</published>
    <updated>2019-10-08T07:35:41.709Z</updated>
    
    <content type="html"><![CDATA[<p>到昨天为止学完了SpringBoot基础，今天开始学redis，然后完了之后写一个SpringBoot和Redis的整合。这篇的整体结构是</p><ol><li><p>基础的操作</p></li><li><p>基础的数据类型和使用场景</p></li></ol><p>那我们就开始吧。</p><a id="more"></a><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><h4 id="打开-关闭-连接之类的"><a href="#打开-关闭-连接之类的" class="headerlink" title="打开/关闭/连接之类的"></a>打开/关闭/连接之类的</h4><p>redis的有点什么特点的，这边就不赘述了，一搜就有好多，这边整点我容易忘记的操作。</p><p>我是Mac端整的，所以直接官网下包，放到根目录下，cd进目录，然后redis-server打开服务端。然后redis-cli 进入客户端操作。</p><p>这边有条命令可以查看redis服务是否开启的。</p><p><code>ps -ef | grep redis</code></p><p>如果看到有个6379的端口开着，那说明我们的服务是启动着的。</p><p>关于关闭redis，一般来说是在redis-cli里直接shutdown，这是断电保护，会把当前操作保存，还有一种暴力的，先通过</p><p><code>ps -ef | grep redis</code>找到redis的pid，然后直接kill - 9 pid，杀了它。</p><h4 id="redis-conf-相关"><a href="#redis-conf-相关" class="headerlink" title="redis.conf 相关"></a>redis.conf 相关</h4><p>redis.conf这个配置文件，它注释写得非常全，我这边主要注意的是三个操作和两个注意点。</p><ol><li><p>requirepass这边设置密码</p></li><li><p>daemonize 设置为yes，这样你退出了终端，你的redis依然在跑</p></li><li><p>把bind注释掉，这样子允许除本机外的客户端访问。</p><p>注释掉以后，要是远程的客户端访问，命令是<br><code>redis-cli -h host -p port -a password</code><br> 解释是这样的：redis-cli –h IP地址 –p 端口 –a 密码</p></li></ol><p>两个注意点:</p><ol><li><strong>save <seconds> <changes></changes></seconds></strong></li></ol><p>这条命令记录的是你的持久化策略，多长时间进行一次保存操作：</p><p>​    <strong>save 900 1</strong></p><p>​    <strong>save 300 10</strong></p><p>​    <strong>save 60 10000</strong></p><p>​    分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改，这边可以根据自己的需求做出修改。</p><ol start="2"><li>MAXMEMORY POLICY 这块</li></ol><p>这边记录的是，当你的缓存不能再放的情况下，你的缓存释放策略。<br>redis缓存的释放有两种方法，一种就是在你设定好了键值对以后，你用expire命令，却规定它什么时候过期。<br>还有一种操作就是这时候，你在conf里面制定你的缓存释放策略，redis的缓存淘汰策略是用LRU算法动态将不常用的数据删除。这边界定不常用的数据提供的选项是：</p><p>1.volatile-lru：设定超时时间的数据中,删除最不常使用的数据.</p><p>2.allkeys-lru：查询所有的key中最近最不常使用的数据进行删除，这是应用最广泛的策略.</p><p>3.volatile-random：在已经设定了超时的数据中随机删除.</p><p>4.allkeys-random：查询所有的key,之后随机删除.</p><p>5.volatile-ttl：查询全部设定超时时间的数据,之后排序,将马上将要过期的数据进行删除操作.</p><p>6.noeviction：如果设置为该属性,则不会进行删除操作,如果内存溢出则报错返回.<br>    volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键<br>    allkeys-lfu：从所有键中驱逐使用频率最少的键</p><p>redis的默认设置是6。可以根据自己项目的需求，自动配置。</p><p>在我们做出了相应的配置后，我们怎么才能去让我们的配置生效呢。<br><code>redis-server redis.conf</code></p><p>这样，redis启动服务端的时候，就会去读取redis.conf里我们的新配置。</p><p>以上是，redis的基础操作。接下来我们谈谈redis提供的数据结构，和我们的日常使用场景。</p><h3 id="数据类型和使用场景"><a href="#数据类型和使用场景" class="headerlink" title="数据类型和使用场景"></a>数据类型和使用场景</h3><h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>最基础的数据结构，常用的操作是</p><pre><code>set key stringget keydel key incr keyincrby key incrementappend key value</code></pre><p>String类型最常用的使用场景就是计数器，并且redis的所有命令都是原子性的，所以当出现竞态条件的时候，比如多个客户端都进行incr命令，并不会出现value重复加1的情况。</p><h4 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h4><p>hash类型最大的特点在于，他可以存储对象。</p><p>常用的操作是:</p><pre><code>hset key field value, field valuehget key fieldhmset key field value  key field valuehmget key field hgetall keyhkeys keyhvals key </code></pre><p>hash最多的使用场景就是存储存储部分变更数据，如用户信息等。</p><h4 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h4><p>list类型的实现方法是双向链表，这样的设计，让它的添加元素的时间复杂度是O(1)，获取越接近两端的元素，速度越快。</p><p>常用的操作是：</p><pre><code>lpush key value1 value2 rpush key value1 lpop key rpop keyllen key lrange key start stop linsert key before/after key1 value1lrem key count value    // 删除列表中前count个值为value的元素，也就是删除列表中指定的值</code></pre><p>list的使用场景是啥呢，</p><p><strong>对数据量大的集合数据删减</strong>：</p><p>列表数据显示、关注列表、粉丝列表、留言评价等…分页、热点新闻（Top5)等。</p><h4 id="Set类型-集合类型"><a href="#Set类型-集合类型" class="headerlink" title="Set类型 集合类型"></a>Set类型 集合类型</h4><p>set类型的内部实现是hashtable，所以加入，删除等操作的时间复杂度都是O(1)。</p><p>常用的操作是：</p><pre><code>sadd key member1 member2 srem key membersmembers keysismember key member//集合间的运算sdiff key1 key2  差集sinter key1 key2 交集sunion key1 key2 并集</code></pre><p>set最突出的特点就是，它多个集合类型键之间可以进行并行，交集，和差集运算。那这些运算有什么用呢，放在现实生活里面的例子就是，找到共同关注、共同喜好等功能。然后因为它内部实现是hashtable，所以它具有唯一性，所以它可以用作记录访问的独立ip，可以存储文章的唯一标签。</p><h4 id="ZSET类型-有序集合类型"><a href="#ZSET类型-有序集合类型" class="headerlink" title="ZSET类型  有序集合类型"></a>ZSET类型  有序集合类型</h4><p>它和集合类型最大的区别就在于，它是有序的。它是通过将每个元素关联一个分数，通过分数，就可以对元素进行排序。有序集合的实现是hashtable和skip list（fuck，又是一个我不熟的数据结构，回头补起来）。</p><p>常用的操作是：</p><pre><code>zadd key score1 member1 score2 member2 //分数支持双精度浮点数zscore key member zrange key start stop [withscores] 从小到大zrevrange key start stop [withscores] zrangebyscore key min max [withscores]//例子 -inf 负无穷 inf 正无穷 不包含(zrangebyscore score  (80 +inf       //高于80分的zincrby key increment member   //增加某个元素的分数zincrby score 4 tom   // tom加4分</code></pre><p>基于它的底层实现结构，zset经常被运用在排行榜的实现中。比如说，我这边写一个文章点击量的排序。</p><pre><code>zadd posts:views 1 post1 2 post2//当有人看了post1zincrby posts:views 2 post1//看一些新的排行zrevrangebyscore posts:views +inf -inf</code></pre><p>这样就可以看到post1在前，post2 在后了。</p><p>以上就是基础的数据类型的操作和使用场景。</p><h3 id="键的操作"><a href="#键的操作" class="headerlink" title="键的操作"></a>键的操作</h3><p>如何查看所有的键呢</p><p>keys *</p><p>如何看某个键是否存在呢</p><p>exists key</p><p>前面做测试，整了各种键，键的命名还是尽可能规范的好，像我上面的，posts:view， 就算的上是有意义的键，不规范的命名，可读性贼差，所以这边我们把之前所有的键全部删掉。</p><p>如何删除所有的键呢</p><p>flushall</p><p>还有之前在清楚内存策略里，我提过可以用expire设置键的存活时间，是这样的</p><p>expire key seconds，单位是秒。比如说expire key1 300。</p><p>想要查看key1的存活时间，可以用，ttl key来查看。</p><p>那我假如说想要移除key1的过期时间呢，就用persist key 1就可以了。</p><p>ok，以上就是redis的基础部分了，接下来我们就开始准备用Springboot 去整合redis了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到昨天为止学完了SpringBoot基础，今天开始学redis，然后完了之后写一个SpringBoot和Redis的整合。这篇的整体结构是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基础的操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基础的数据类型和使用场景&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那我们就开始吧。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Redis" scheme="https://junshang11.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>异常处理最佳实践</title>
    <link href="https://junshang11.com/2019/10/03/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://junshang11.com/2019/10/03/异常处理最佳实践/</id>
    <published>2019-10-02T16:00:00.000Z</published>
    <updated>2019-10-08T07:35:54.548Z</updated>
    
    <content type="html"><![CDATA[<p>到今天为止，SpringBoot的基础部分已经学完了，从yaml文件开始，到web，在restful规范那边，然后到SpringBoot和MyBatis的整合，没细看jpa，因为真的不太喜欢hibernate写的那种方式，封装的太好了，就显得死板，相比之下，MyBatis在写动态SQL的时候真的是舒服。</p><p>到thymeleaf的模版引擎，就感觉还行，终于脱离了jsp，听无数人说这玩意已经不行了，到了thymeleaf这边，是终于和它告别了。但肯定不是最后的目标吧，我想用vue写前端，后端用SpringBoot，然后实现一个真正的前后端分离，然后再去投简历。</p><p>这篇讲的是异常，说实话，我之前写的项目里，异常处理是基本没有的，后端直接try catch，打印完了事，一点给前端的反馈都没有的；再加上我前面用vo里的AjaxResponse封装请求的信息，里面加了请求响应状态码之类的，我写了成功以后会将请求信息封装进AjaxResponse里并返回，我没有考虑到要是出现错误了，它能用什么方法去“发现”错误并拦截下来。</p><p>所以这篇是就主讲异常处理最佳实践，这边将用SpringBoot框架作演示，对SSM框架整合同样适用，关键是异常处理的思想。</p><p>资料来源是csdn啊，segmentfault和博客园的好多文章，这边开始做一个整合。</p><a id="more"></a><h3 id="什么是一个好的异常处理标准"><a href="#什么是一个好的异常处理标准" class="headerlink" title="什么是一个好的异常处理标准"></a>什么是一个好的异常处理标准</h3><h4 id="面向相关方友好"><a href="#面向相关方友好" class="headerlink" title="面向相关方友好"></a>面向相关方友好</h4><ol><li>后端开发人员职责单一，只需要将异常捕获并转换为自定义异常一直对外抛出。不需要去想页面跳转404，以及异常响应的数据结构的设计。</li><li>面向前端人员友好，后端返回给前端的数据应该有统一的数据结构，统一的规范。不能一个人一个响应的数据结构。而在此过程中不需要后端开发人员做更多的工作，交给全局异常处理器去处理“异常”到“响应数据结构”的转换。</li><li>面向用户友好，用户能够清楚的知道异常产生的原因。这就要求自定义异常，全局统一处理，ajax接口请求响应统一的异常数据结构，页面模板请求统一跳转到404页面。</li></ol><h4 id="相应的开发规范是："><a href="#相应的开发规范是：" class="headerlink" title="相应的开发规范是："></a>相应的开发规范是：</h4><ol><li><p>Controller、Service、DAO层拦截异常转换为自定义异常，不允许将异常私自截留。必须对外抛出。</p></li><li><p>统一数据响应代码，使用httpstatusode，不要自定义。自定义不方便记忆。200请求成功，400用户输入错误导致的异常，500系统内部异常，999未知异常。</p></li><li><p>自定义异常里面有message属性，一定用友好的语言描述异常，并赋值给message.</p></li><li><p>不允许对父类Excetion统一catch，要分小类catch，这样能够清楚地将异常转换为自定义异常传递给前端。</p></li></ol><h4 id="对照着开发规范，我们需要的是"><a href="#对照着开发规范，我们需要的是" class="headerlink" title="对照着开发规范，我们需要的是"></a>对照着开发规范，我们需要的是</h4><ol><li>一个异常分类的枚举，统一异常分类编码</li><li>自定义异常的结构，需要有异常错误编码和异常信息描述，合理的异常信息描述能更好地帮助开发获得反馈</li><li>统一响应前端的数据结构，创建一个boolean值，如果响应未成功，前端应该有相应的提示页面</li><li>全局异常处理，在拿到异常后，对异常进行处理</li><li>服务端数据校验</li><li>error.html页面，前端响应出现问题，将跳转到这个页面</li></ol><h3 id="异常处理需要的结构"><a href="#异常处理需要的结构" class="headerlink" title="异常处理需要的结构"></a>异常处理需要的结构</h3><p>结构篇将解决以上1，2，3出现的问题，它包含一个异常的枚举类，一个自定义异常，以及反馈给前端的数据结构。</p><p>首先我们将制定一个异常的枚举类，将异常分类固化下来：</p><pre><code>public enum CustomExceptionType {    USER_INPUT_ERROR(400,"用户输入异常"),    SYSTEM_ERROR (500,"系统服务异常"),    OTHER_ERROR(999,"其他未知异常");       CustomExceptionType(int code, String typeDesc) {        this.code = code;        this.typeDesc = typeDesc;    }     private String typeDesc;//异常类型中文描述     private int code; //code      public String getTypeDesc() {        return typeDesc;    }       public int getCode() {        return code;    }}</code></pre><p>接下来我们将实现一个自定义异常的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="comment">//异常错误编码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code ;</span><br><span class="line">    <span class="comment">//异常信息</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomException</span><span class="params">(CustomExceptionType exceptionTypeEnum, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = exceptionTypeEnum.getCode();</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反馈给前端的数据结构，之前我写过这个，遵循RESTful风格，我反馈给前端的不仅仅是我的数据，还要带上我的状态码。这边的代码是增强版本，除了考虑响应成功的情况，我们还将考虑响应不成功的话，得返回的信息是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AjaxResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isok; <span class="comment">// ajax请求是否成功</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;        <span class="comment">// http status code</span></span><br><span class="line">    <span class="keyword">private</span> String message; <span class="comment">//请求失败的的提示信息。</span></span><br><span class="line">    <span class="keyword">private</span> Object data;     <span class="comment">//请求成功时，需要响应给前端的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AjaxResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//请求出现异常时的响应数据封装</span></span><br><span class="line">  <span class="comment">//当出现异常时，将从前面定义的自定义异常中，找到相对应的异常，拿异常码和信息，并打包返回出去。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AjaxResponse <span class="title">error</span><span class="params">(CustomException e)</span> </span>&#123;</span><br><span class="line">        AjaxResponse resultBean = <span class="keyword">new</span> AjaxResponse();</span><br><span class="line">        resultBean.setIsok(<span class="keyword">false</span>);</span><br><span class="line">        resultBean.setCode(e.getCode());</span><br><span class="line">        <span class="keyword">if</span>(e.getCode() == CustomExceptionType.USER_INPUT_ERROR.getCode())&#123;</span><br><span class="line">            resultBean.setMessage(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e.getCode() == CustomExceptionType.SYSTEM_ERROR.getCode())&#123;</span><br><span class="line">            resultBean.setMessage(e.getMessage() + <span class="string">",系统出现异常，请联系管理员电话：xxxx进行处理!"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resultBean.setMessage(<span class="string">"系统出现未知异常，请联系管理员电话：xxx进行处理!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//请求成功时的响应数据封装，没有响应数据（比如删除修改成功）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AjaxResponse <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AjaxResponse resultBean = <span class="keyword">new</span> AjaxResponse();</span><br><span class="line">        resultBean.setIsok(<span class="keyword">true</span>);</span><br><span class="line">        resultBean.setCode(<span class="number">200</span>);</span><br><span class="line">        resultBean.setMessage(<span class="string">"success"</span>);</span><br><span class="line">        <span class="keyword">return</span> resultBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//请求成功时的响应数据封装，有响应数据（比如查询成功）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AjaxResponse <span class="title">success</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        AjaxResponse resultBean = <span class="keyword">new</span> AjaxResponse();</span><br><span class="line">        resultBean.setIsok(<span class="keyword">true</span>);</span><br><span class="line">        resultBean.setCode(<span class="number">200</span>);</span><br><span class="line">        resultBean.setMessage(<span class="string">"success"</span>);</span><br><span class="line">        resultBean.setData(data);</span><br><span class="line">        <span class="keyword">return</span> resultBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h4><p>全局异常是针对后端开发的，在做crud的过程中，出现的异常将不断外抛出来，这时候我们就需要在最外面利用全局异常处理去处理异常。</p><p>全局处理需要一个 @ControllerAdvice 的注解，它将监听所有的Controller，当Controller抛出异常后，就会在@ExceptionHandler(CustomException.class) 对异常进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebExceptionHandler</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//对自定义异常的处理</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(CustomException.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AjaxResponse <span class="title">customerException</span><span class="params">(CustomException e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e.getCode() == CustomExceptionType.SYSTEM_ERROR.getCode())&#123;</span><br><span class="line">                 <span class="comment">//400异常不需要持久化，将异常信息以友好的方式告知用户就可以</span></span><br><span class="line">                <span class="comment">//TODO 将500异常信息持久化处理，方便运维人员处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> AjaxResponse.error(e);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//对自定义异常没包括的异常进行处理</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception.class)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AjaxResponse <span class="title">exception</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO 将异常信息持久化处理，方便运维人员处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有被程序员发现，并转换为CustomException的异常，都是其他异常或者未知异常.</span></span><br><span class="line">        <span class="keyword">return</span> AjaxResponse.error(<span class="keyword">new</span> CustomException(CustomExceptionType.OTHER_ERROR,<span class="string">"未知异常"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后端数据校验和对数据校验信息的异常处理"><a href="#后端数据校验和对数据校验信息的异常处理" class="headerlink" title="后端数据校验和对数据校验信息的异常处理"></a>后端数据校验和对数据校验信息的异常处理</h4><p>这边不讨论前端的数据校验，后端的数据校验这块，我们通常用JSR 303对数据进行校验。</p><p>导个包。</p><dependency>            <groupid>org.hibernate.validator</groupid>            <artifactid>hibernate-validator</artifactid>            <version>6.0.10.Final</version>        </dependency>        <dependency>            <groupid>org.hibernate</groupid>            <artifactid>hibernate-validator-annotation-processor</artifactid>            <version>6.0.10.Final</version></dependency><p>然后就可以将一些常用注解加在VO的bean的属性字段上，然后在参数校验的方法上加@Valid注解，这样就可以了。常用的注解很多，<a href="https://www.ibm.com/developerworks/cn/java/j-lo-jsr303/index.html" target="_blank" rel="noopener">具体的参考这边的表格</a>。</p><p>在做完参数校验后，如果校验失败，会抛出BindException或MethodArgumentNotValidException这两种异常，那我们就需要对我们上面定义的异常类中进行添加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebExceptionHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">//之前的一些实现</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(MethodArgumentNotValidException.class)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AjaxResponse <span class="title">handleBindException</span><span class="params">(MethodArgumentNotValidException ex)</span> </span>&#123;</span><br><span class="line">    FieldError fieldError = ex.getBindingResult().getFieldError();</span><br><span class="line">    <span class="keyword">return</span> AjaxResponse.error(<span class="keyword">new</span> CustomException(CustomExceptionType.USER_INPUT_ERROR,fieldError.getDefaultMessage()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(BindException.class)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AjaxResponse <span class="title">handleBindException</span><span class="params">(BindException ex)</span> </span>&#123;</span><br><span class="line">    FieldError fieldError = ex.getBindingResult().getFieldError();</span><br><span class="line">    <span class="keyword">return</span> AjaxResponse.error(<span class="keyword">new</span> CustomException(CustomExceptionType.USER_INPUT_ERROR,fieldError.getDefaultMessage()));</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>以上我们就实现了对Controller层出现的绝大多数异常的处理，但我们有一个很麻烦的问题，就是如果说数据出现错误，我们反回给前端的是AjaxResponse对象，它不是ModelAndView，所以就无法跳转到error.html页面里。这边我们可以用Aop，将CostumException转换成ModelAndViewException。</p><h3 id="AOP实现的异常处理方案"><a href="#AOP实现的异常处理方案" class="headerlink" title="AOP实现的异常处理方案"></a>AOP实现的异常处理方案</h3><p>上面写了我们这次想要达到的目的，将CostumException转换成ModelAndViewException。我们需要采取的操作是：</p><ol><li>用面向切面的方式，将CustomException转换为ModelAndViewException。</li><li>全局异常处理器拦截ModelAndViewException，返回ModelAndView，即error.html页面</li><li>切入点是带自定义注解@ModelView注解的Controller层方法</li></ol><p>首先我们需要新定义一个异常类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ModelViewException extends RuntimeException&#123;</span><br><span class="line"></span><br><span class="line">    //异常错误编码</span><br><span class="line">    private int code ;</span><br><span class="line">    //异常信息</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public static ModelViewException transfer(CustomException e) &#123;</span><br><span class="line">        return new ModelViewException(e.getCode(),e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ModelViewException(int code, String message)&#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们自定义这个注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)//只能在方法上使用此注解</span><br><span class="line">public @interface ModelView &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它起到一个标注的作用。接下来我们详细写这个注解的实现。它将以@ModelView注解为切入点，面向切面编程,将CustomException转换为ModelViewException抛出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">@Slf4j</span><br><span class="line">public class ModelViewAspect &#123;</span><br><span class="line">    </span><br><span class="line">    //设置切入点：这里直接拦截被@ModelView注解的方法</span><br><span class="line">    @Pointcut(&quot;@annotation(com.junshang11.springboot_crud.common.exception.ModelView)&quot;)</span><br><span class="line">    public void pointcut() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 当有ModelView的注解的方法抛出异常的时候，做如下的处理</span><br><span class="line">     */</span><br><span class="line">    @AfterThrowing(pointcut=&quot;pointcut()&quot;,throwing=&quot;e&quot;)</span><br><span class="line">    public void afterThrowable(Throwable e) &#123;</span><br><span class="line">        log.error(&quot;切面发生了异常：&quot;, e);</span><br><span class="line">        if(e instanceof  CustomException)&#123;</span><br><span class="line">            throw ModelViewException.transfer((CustomException) e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们要在全局异常处理类里面，添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebExceptionHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">//之前的一些实现</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(ModelViewException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">viewExceptionHandler</span><span class="params">(HttpServletRequest req, ModelViewException e)</span> </span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将异常信息设置如modelAndView</span></span><br><span class="line">        modelAndView.addObject(<span class="string">"exception"</span>, e);</span><br><span class="line">        modelAndView.addObject(<span class="string">"url"</span>, req.getRequestURL());</span><br><span class="line">        modelAndView.setViewName(<span class="string">"error"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回ModelAndView</span></span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="好好解释一下"><a href="#好好解释一下" class="headerlink" title="好好解释一下"></a>好好解释一下</h4><p>这边来解释一下这个的机制是什么：</p><p>我们需要达到的目的是，当有跳转的controller，比如下面这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/theymeleaf&quot;)</span><br><span class="line">public String index(Model model) &#123;</span><br><span class="line">    List&lt;ArticleVO&gt; articles = articleRestService.getAll();</span><br><span class="line">    model.addAttribute(&quot;articles&quot;, articles);</span><br><span class="line">    return &quot;theymeleaftemp&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现了异常，我们现在不要它跳转到theymeleaftemp.html页面，而是跳转到error.html页面。我们怎么做呢。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@ModelView</span><br><span class="line">@GetMapping(&quot;/theymeleaf&quot;)</span><br><span class="line">public String index(Model model) &#123;</span><br><span class="line">    List&lt;ArticleVO&gt; articles = articleRestService.getAll();</span><br><span class="line">    model.addAttribute(&quot;articles&quot;, articles);</span><br><span class="line">    return &quot;theymeleaftemp&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上@ModelView这个自定义注解，当有ModelView的注解的方法抛出异常的时候。它将用面向切面的形式，将这个CostumException 转化成 ModelViewException。这时候，我们的全局异常处理会监听到ModelViewException，他将异常信息封装到ModelAndView中，并设置跳转方向，error.html。</p><p>以上这些才构成一个完整的，体系化的异常处理最佳实践。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这是第一次去探究这么一个大的问题，好吧，最开始的时候并没有意识到这是个这么大的问题，越看资料越多，越觉得这个没有全，那个不完整，最后综合了好几篇实践，写出来这么一篇，算是很完善了吧。开心。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到今天为止，SpringBoot的基础部分已经学完了，从yaml文件开始，到web，在restful规范那边，然后到SpringBoot和MyBatis的整合，没细看jpa，因为真的不太喜欢hibernate写的那种方式，封装的太好了，就显得死板，相比之下，MyBatis在写动态SQL的时候真的是舒服。&lt;/p&gt;
&lt;p&gt;到thymeleaf的模版引擎，就感觉还行，终于脱离了jsp，听无数人说这玩意已经不行了，到了thymeleaf这边，是终于和它告别了。但肯定不是最后的目标吧，我想用vue写前端，后端用SpringBoot，然后实现一个真正的前后端分离，然后再去投简历。&lt;/p&gt;
&lt;p&gt;这篇讲的是异常，说实话，我之前写的项目里，异常处理是基本没有的，后端直接try catch，打印完了事，一点给前端的反馈都没有的；再加上我前面用vo里的AjaxResponse封装请求的信息，里面加了请求响应状态码之类的，我写了成功以后会将请求信息封装进AjaxResponse里并返回，我没有考虑到要是出现错误了，它能用什么方法去“发现”错误并拦截下来。&lt;/p&gt;
&lt;p&gt;所以这篇是就主讲异常处理最佳实践，这边将用SpringBoot框架作演示，对SSM框架整合同样适用，关键是异常处理的思想。&lt;/p&gt;
&lt;p&gt;资料来源是csdn啊，segmentfault和博客园的好多文章，这边开始做一个整合。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="https://junshang11.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis的xml配置</title>
    <link href="https://junshang11.com/2019/10/01/mybatis%E7%9A%84xml%E9%85%8D%E7%BD%AE/"/>
    <id>https://junshang11.com/2019/10/01/mybatis的xml配置/</id>
    <published>2019-09-30T16:00:00.000Z</published>
    <updated>2019-10-06T00:27:40.997Z</updated>
    
    <content type="html"><![CDATA[<p>今天写demo的时候，突然发现MyBatis不太会写了，那个格式，可能MyBatis generator用多了，就是这个不好吧，直接写不看文档，格式啥的容易忘，所以这边记录一下。</p><a id="more"></a><p>1.mybatis的xml配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.配置resultMap</span><br><span class="line">&lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;xx&quot; &gt;</span><br><span class="line">    &lt;id column=&quot;id&quot; property=&quot;ID&quot; jdbcType=&quot;BIGINT&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;aa&quot; property=&quot;aa&quot; jdbcType=&quot;VARCHAR&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;bb&quot; property=&quot;bb&quot; jdbcType=&quot;INTEGER&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;cc&quot; property=&quot;cc&quot; jdbcType=&quot;DECIMAL&quot; javaType=&quot;java.math.BigDecimal&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;dd&quot; property=&quot;dd&quot; jdbcType=&quot;DATE&quot; /&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure><p>2.通用sql短语</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  &lt;sql id=&quot;Base_Column_List&quot; &gt;</span><br><span class="line">    aa, bb</span><br><span class="line">  &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line"> &lt;sql id=&quot;where&quot;&gt;</span><br><span class="line">    &lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND|OR&quot;&gt;</span><br><span class="line">        &lt;if test=&quot;id != null and id != &apos;&apos;&quot;&gt;</span><br><span class="line">            AND t.ID = #&#123;id&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;content != null and content != &apos;&apos;&quot;&gt;</span><br><span class="line">            AND t.CONTENT LIKE concat(&apos;%&apos;, #&#123;content&#125;,&apos;%&apos;)</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        AND t.APP_CODE IN</span><br><span class="line">        &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;appcodes&quot;</span><br><span class="line">            open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">            #&#123;item&#125;</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">        and t.USER_ID=u.id and t.REMOVED=0</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure><p>3.需要验证的插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &lt;insert id=&quot;insert&quot; parameterType=&quot;xxx&quot;</span><br><span class="line">    useGeneratedKeys=&quot;true&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">    insert into xxx (</span><br><span class="line">    &lt;trim suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">        &lt;if test=&quot;title != null and title != &apos;&apos; &quot;&gt;</span><br><span class="line">            TITLE ,</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">    ) VALUES (</span><br><span class="line">    &lt;trim suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">        &lt;if test=&quot;title != null and title != &apos;&apos; &quot;&gt;</span><br><span class="line">            #&#123;title&#125; ,</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">    )</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><p>4.需要验证的更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;update&quot; parameterType=&quot;xxx&quot;&gt;</span><br><span class="line">    UPDATE xxx</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">        &lt;if test=&quot;title != null and title != &apos;&apos; &quot;&gt;</span><br><span class="line">            TITLE = #&#123;title&#125; ,</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    WHERE</span><br><span class="line">    ID = #&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><p>5.批量更新ticketid和SeatNo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=&quot;xxxUpdate&quot; parameterType=&quot;java.util.List&quot;&gt;</span><br><span class="line">    update xxx</span><br><span class="line">    &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">        &lt;trim prefix=&quot;AA =case&quot; suffix=&quot;end,&quot;&gt;</span><br><span class="line">            &lt;foreach collection=&quot;orders&quot; item=&quot;item&quot; index=&quot;index&quot;&gt;</span><br><span class="line">                &lt;if test=&quot;item.aa !=null&quot;&gt;</span><br><span class="line">                    when ID=#&#123;item.id&#125; then #&#123;item.aa&#125;</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">            &lt;/foreach&gt;</span><br><span class="line">        &lt;/trim&gt;</span><br><span class="line">        &lt;trim prefix=&quot;BB =case&quot; suffix=&quot;end,&quot;&gt;</span><br><span class="line">            &lt;foreach collection=&quot;orders&quot; item=&quot;item&quot; index=&quot;index&quot;&gt;</span><br><span class="line">                &lt;if test=&quot;item.bb !=null&quot;&gt;</span><br><span class="line">                    when ID=#&#123;item.id&#125; then #&#123;item.bb&#125;</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">            &lt;/foreach&gt;</span><br><span class="line">        &lt;/trim&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">    where ID in</span><br><span class="line">    &lt;foreach collection=&quot;orders&quot; index=&quot;index&quot; item=&quot;item&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;</span><br><span class="line">        #&#123;item.id,jdbcType=BIGINT&#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><p>使case when求和算数sql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    sum(</span><br><span class="line">        CASE</span><br><span class="line">        WHEN `REMOVED` = 0 THEN</span><br><span class="line">            1</span><br><span class="line">        ELSE</span><br><span class="line">            0</span><br><span class="line">        END</span><br><span class="line">    )</span><br><span class="line">FROM</span><br><span class="line">    xxx;</span><br></pre></td></tr></table></figure><p>mybatis可以使用string给数据库int类型赋值<br>springboot中开启日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><p>1.ORDER BY ${columnName}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里 MyBatis 不会修改或转义字符串。NOTE 用这种方式接受用户的输入，并将其用于语句中的参数是不安全的，会导致潜在的 SQL 注入攻击，因此要么不允许用户输入这些字段，要么自行转义并检验。</span><br></pre></td></tr></table></figure><p>2.mybatis默认是事务不提交</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天写demo的时候，突然发现MyBatis不太会写了，那个格式，可能MyBatis generator用多了，就是这个不好吧，直接写不看文档，格式啥的容易忘，所以这边记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MyBatis" scheme="https://junshang11.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Aop相关的知识</title>
    <link href="https://junshang11.com/2019/09/29/aop%E7%9B%B8%E5%85%B3/"/>
    <id>https://junshang11.com/2019/09/29/aop相关/</id>
    <published>2019-09-28T16:00:00.000Z</published>
    <updated>2019-10-07T09:19:12.930Z</updated>
    
    <content type="html"><![CDATA[<p>因为我看到异常处理那边需要用到这个，所以我们今天复习一下Aop的相关知识。</p><a id="more"></a><h3 id="什么是Aop"><a href="#什么是Aop" class="headerlink" title="什么是Aop"></a>什么是Aop</h3><p>Aop，又叫面向切片编程，Spring的两大特性之一，代理模式的最佳实现。</p><p>Aop是对核心业务没有实现的小功能的实现，它可以应用在</p><p>(1)日志记录;<br>(2)性能统计;<br>(3)安全控制(可以理解为权限控制);<br>(4)事务处理;<br>(5)异常处理;</p><h3 id="Aop的核心要点"><a href="#Aop的核心要点" class="headerlink" title="Aop的核心要点"></a>Aop的核心要点</h3><h4 id="连接点-Joinpoint"><a href="#连接点-Joinpoint" class="headerlink" title="连接点(Joinpoint)"></a>连接点(Joinpoint)</h4><p>增强程序执行的某个特定位置(要在哪个地方做增强操作)。Spring仅支持方法的连接点，既仅能在方法调用前，方法调用后，方法抛出异常时等这些程序执行点进行织入增强。</p><h4 id="切点-Pointcut"><a href="#切点-Pointcut" class="headerlink" title="切点(Pointcut)"></a>切点(Pointcut)</h4><p>切点是一组连接点的集合。Aop通过”切点”定位特定的连接点。通过数据库查询的概念来理解切点和连接点的关系再适合不过来:连接点相当于数据库中的记录，而切点相当于查询条件。</p><h4 id="增强-Advice"><a href="#增强-Advice" class="headerlink" title="增强(Advice)"></a>增强(Advice)</h4><p>增强是织入到目标类连接点上的一段程序代码。表示要在连接点上做的操作。</p><h4 id="切面-Aspect"><a href="#切面-Aspect" class="headerlink" title="切面(Aspect)"></a>切面(Aspect)</h4><p>切面由切点和增强(引介)组成(可以包含多个切点和多个增强)，它既包括横切逻辑的定义，也包括连接点的定义，Spring Aop就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的链接点中。</p><h4 id="Spring-Aop常用注解如下"><a href="#Spring-Aop常用注解如下" class="headerlink" title="Spring Aop常用注解如下:"></a>Spring Aop常用注解如下:</h4><p>@Aspect(定义切面)<br>@Pointcut(定义切点)<br>@Before(标注Before Advice定义所在的方法)<br>@After-returning(标注After Returning Advice定义所在的方法)<br>@After-throwing(标注After Throwing Advice定义所在的方法)<br>@After(标注After(Finally)Advice定义所在的方法)<br>@Around(标注Around Advice定义所在的方法)</p><p>其实总结一下就是，@Aspect告诉Spring这是我的一个切面，我的操作在里面；@Pointcut告诉Spring，我要往哪几个包里切，@Before，@After这些告诉Spring，方法执行前还是后，进行我的操作。</p><h3 id="使用Aop统一处理Web请求日志"><a href="#使用Aop统一处理Web请求日志" class="headerlink" title="使用Aop统一处理Web请求日志"></a>使用Aop统一处理Web请求日志</h3><p>上面的都是概念点，我们这边利用Aop来实现一个web请求日志的控制台显示。</p><p>首先导包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>接下来我们定义一个切片类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Aspect  //这是一个切片</span><br><span class="line">@Component //放入bean</span><br><span class="line">public class logAsp &#123;</span><br><span class="line"></span><br><span class="line">   //指定切入点</span><br><span class="line">   //几个*的意思，任意返回值，任意类，任意方法，任意参数</span><br><span class="line">   @Pointcut(&quot;execution(public * com.junshang11.springboot_crud.controller.*.*(..))&quot;)</span><br><span class="line">   public void weblog() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //在执行前进行的操作</span><br><span class="line">   @Before(&quot;weblog()&quot;)</span><br><span class="line">   public void doBefore(JoinPoint joinPoint) &#123;</span><br><span class="line">      System.out.println(&quot;我是前置通知!!!&quot;);</span><br><span class="line">      //获取目标方法的参数信息</span><br><span class="line">      Object[] obj = joinPoint.getArgs();</span><br><span class="line">      Signature signature = joinPoint.getSignature();</span><br><span class="line">      //代理的是哪一个方法</span><br><span class="line">      System.out.println(&quot;方法：&quot; + signature.getName());</span><br><span class="line">      //AOP代理类的名字</span><br><span class="line">      System.out.println(&quot;方法所在包:&quot; + signature.getDeclaringTypeName());</span><br><span class="line">      //AOP代理类的类（class）信息</span><br><span class="line">      signature.getDeclaringType();</span><br><span class="line">      MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">      String[] strings = methodSignature.getParameterNames();</span><br><span class="line">      System.out.println(&quot;参数名：&quot; + Arrays.toString(strings));</span><br><span class="line">      System.out.println(&quot;参数值ARGS : &quot; + Arrays.toString(joinPoint.getArgs()));</span><br><span class="line">      // 接收到请求，记录请求内容</span><br><span class="line">      ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">      HttpServletRequest req = attributes.getRequest();</span><br><span class="line">      // 记录下请求内容</span><br><span class="line">      System.out.println(&quot;请求URL : &quot; + req.getRequestURL().toString());</span><br><span class="line">      System.out.println(&quot;HTTP_METHOD : &quot; + req.getMethod());</span><br><span class="line">      System.out.println(&quot;IP : &quot; + req.getRemoteAddr());</span><br><span class="line">      System.out.println(&quot;CLASS_METHOD : &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   //执行后进行的操作</span><br><span class="line">   @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;)</span><br><span class="line">public void doAfterReturning(Object ret) throws Throwable &#123;</span><br><span class="line">// 处理完请求，返回内容</span><br><span class="line">System.out.println(&quot;方法的返回值 : &quot; + ret);</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这样就能在控制台看到，日志信息的打印了。</p><p><img src="/Users/junshang/Hexo/source/images/aop%E6%97%A5%E5%BF%97.png" alt></p><h3 id="利用自定义注解使用Aop"><a href="#利用自定义注解使用Aop" class="headerlink" title="利用自定义注解使用Aop"></a>利用自定义注解使用Aop</h3><p>有些功能，比如说参数校验，性能统计之类的，很多地方都需要用，那每次配置很麻烦，所以我们也可以用自定义注解的方式来实现Aop的功能。</p><p>首先我们需要自定义一个注解，和定义接口很像，只不过前面加个@ 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Timing &#123;</span><br><span class="line">   String param() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就定义了一个叫Timing的注解。</p><p>接下来我们对@Timing的功能进行解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class timingimpl &#123;</span><br><span class="line">   @Around(&quot;@annotation(Timing)&quot;)</span><br><span class="line">   public Object around(ProceedingJoinPoint joinPoint, DoneTime doneTime) throws Throwable &#123;</span><br><span class="line">      System.out.println(&quot;方法开始时间是:&quot;+new Date());</span><br><span class="line">      Object o = joinPoint.proceed();</span><br><span class="line">      System.out.println(&quot;方法结束时间是:&quot;+new Date()) ;</span><br><span class="line">      return o;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Timing将以环绕通知的方式，记录请求所需要的时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为我看到异常处理那边需要用到这个，所以我们今天复习一下Aop的相关知识。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="https://junshang11.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>敏感字段的处理和druid配置</title>
    <link href="https://junshang11.com/2019/09/27/%E6%95%8F%E6%84%9F%E5%AD%97%E6%AE%B5%E7%9A%84%E5%A4%84%E7%90%86%E5%92%8Cdruid%E9%85%8D%E7%BD%AE/"/>
    <id>https://junshang11.com/2019/09/27/敏感字段的处理和druid配置/</id>
    <published>2019-09-26T16:00:00.000Z</published>
    <updated>2019-10-05T10:09:32.051Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始接触SpringBoot和MyBatis的整合的时候，突然想起来得把数据库连接池给换了，因为之前看到文章说，c3p0已经很久不维护了，于是搜了一下，决定用阿里推出的druid作为以后的核心数据库连接池。</p><p>然后还有一个问题是，我每次的密码和用户名都是直接放在那边的，在生产环境里，是不可能这么放的吧，所以又找了一下，发现一个Jasypt的工具，可以设定自己的盐，然后他会帮助你用PBEWithMD5AndDES的加密方式加密。</p><p>接下来就使用一下这两个工具。</p><a id="more"></a><h3 id="Jasypt工具的使用"><a href="#Jasypt工具的使用" class="headerlink" title="Jasypt工具的使用"></a>Jasypt工具的使用</h3><p>首先导包，它是可以和Spring集成的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后在工具类里面创建一个新的类。做一个main方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">encrypt</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      BasicTextEncryptor textEncryptor = <span class="keyword">new</span> BasicTextEncryptor();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//加密所需要的盐</span></span><br><span class="line">      textEncryptor.setPassword(<span class="string">"mimatest"</span>);</span><br><span class="line">      <span class="comment">//对用户名和密码进行加密</span></span><br><span class="line">      String usename = textEncryptor.encrypt(<span class="string">"root"</span>);</span><br><span class="line">      String password = textEncryptor.encrypt(<span class="string">"ericshang11"</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"username = "</span>+ usename);</span><br><span class="line">      System.out.println(<span class="string">"password = "</span> + password);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们可以在控制台发现，这两个数据都被加密了。复制控制台这两个值。</p><p>那我们在application.yml里，怎么去将这两个值解密呢。</p><p>只需要在需要解密的外面，包裹一个ENC()，就好了。</p><p>像这样ENC(BzP/xEfXux6GSVNHlvtJcA==)。</p><p>接下来我们开始配置druid。</p><h3 id="druid的配置"><a href="#druid的配置" class="headerlink" title="druid的配置"></a>druid的配置</h3><p>首先依旧是导包，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.25&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>接下来，我们要在application.yml中，对datasource做些修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: ENC(BzP/xEfXux6GSVNHlvtJcA==)</span><br><span class="line">    password: ENC(iYNvsaHhxmO09hNKQcPI37BXfbY2Au2W)</span><br><span class="line">    url: jdbc:mysql://127.0.0.1:3306/testdb</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line">      # 下面为连接池的补充设置，应用到上面所有数据源中</span><br><span class="line">      # 初始化大小，最小，最大</span><br><span class="line">      initialSize: 1</span><br><span class="line">      minIdle: 3</span><br><span class="line">      maxActive: 20</span><br><span class="line">      # 配置获取连接等待超时的时间</span><br><span class="line">      maxWait: 60000</span><br><span class="line">      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">      timeBetweenEvictionRunsMillis: 60000</span><br><span class="line">      # 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">      minEvictableIdleTimeMillis: 30000</span><br><span class="line">      validationQuery: select &apos;x&apos;</span><br><span class="line">      testWhileIdle: true</span><br><span class="line">      testOnBorrow: false</span><br><span class="line">      testOnReturn: false</span><br><span class="line">      # 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">      poolPreparedStatements: true</span><br><span class="line">      maxPoolPreparedStatementPerConnectionSize: 20</span><br><span class="line">      # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙</span><br><span class="line">      filters: stat,wall,slf4j</span><br><span class="line">      # 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">      connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000</span><br><span class="line">      # 合并多个DruidDataSource的监控数据</span><br><span class="line">      #useGlobalDataSourceStat: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jasypt:</span><br><span class="line">  encryptor:</span><br><span class="line">    password: mimatest</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  configuration:</span><br><span class="line">    mapUnderscoreToCamelCase: true</span><br></pre></td></tr></table></figure><p>接下来，我们需要对druid进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DruidDBConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean druidServlet() &#123;</span><br><span class="line">        ServletRegistrationBean reg = new ServletRegistrationBean();</span><br><span class="line">        reg.setServlet(new StatViewServlet());</span><br><span class="line">        reg.addUrlMappings(&quot;/druid/*&quot;);</span><br><span class="line">        //设置控制台管理用户</span><br><span class="line">        reg.addInitParameter(&quot;loginUsername&quot;,&quot;root&quot;);</span><br><span class="line">        reg.addInitParameter(&quot;loginPassword&quot;,&quot;123456&quot;);</span><br><span class="line">        // 禁用HTML页面上的“Reset All”功能</span><br><span class="line">        reg.addInitParameter(&quot;resetEnable&quot;,&quot;false&quot;);</span><br><span class="line">        //reg.addInitParameter(&quot;allow&quot;, &quot;127.0.0.1&quot;); //白名单</span><br><span class="line">        return reg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean filterRegistrationBean() &#123;</span><br><span class="line">        //创建过滤器</span><br><span class="line">        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();</span><br><span class="line">        filterRegistrationBean.setFilter(new WebStatFilter());</span><br><span class="line">        Map&lt;String, String&gt; initParams = new HashMap&lt;String, String&gt;();</span><br><span class="line">        //忽略过滤的形式</span><br><span class="line">        initParams.put(&quot;exclusions&quot;, &quot;*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*&quot;);</span><br><span class="line">        filterRegistrationBean.setInitParameters(initParams);</span><br><span class="line">        //设置过滤器过滤路径</span><br><span class="line">        filterRegistrationBean.addUrlPatterns(&quot;/*&quot;);</span><br><span class="line">        return filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们的druid就开启了，接下来写个测试案例后，在进入</p><p><a href="http://localhost:8080/druid/index.html" target="_blank" rel="noopener">druid监控器</a></p><p>就可以看到刚才那次请求的相关信息了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天开始接触SpringBoot和MyBatis的整合的时候，突然想起来得把数据库连接池给换了，因为之前看到文章说，c3p0已经很久不维护了，于是搜了一下，决定用阿里推出的druid作为以后的核心数据库连接池。&lt;/p&gt;
&lt;p&gt;然后还有一个问题是，我每次的密码和用户名都是直接放在那边的，在生产环境里，是不可能这么放的吧，所以又找了一下，发现一个Jasypt的工具，可以设定自己的盐，然后他会帮助你用PBEWithMD5AndDES的加密方式加密。&lt;/p&gt;
&lt;p&gt;接下来就使用一下这两个工具。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="https://junshang11.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>RESTful封装思想，Dozer使用</title>
    <link href="https://junshang11.com/2019/09/26/RESTful/"/>
    <id>https://junshang11.com/2019/09/26/RESTful/</id>
    <published>2019-09-25T16:00:00.000Z</published>
    <updated>2019-10-06T01:46:45.654Z</updated>
    
    <content type="html"><![CDATA[<p>Springboot第二天，又学到了很多很有意思的东西，这边来记录一下这三个比较amaze我的。</p><a id="more"></a><h3 id="先说RESTful学到的封装写法"><a href="#先说RESTful学到的封装写法" class="headerlink" title="先说RESTful学到的封装写法"></a>先说RESTful学到的封装写法</h3><p>RESTful风格概念我这边就不多写了，因为之前学ssm的时候自己就查过详细的资料，这边上个链接，忘了再来看看 <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a>。</p><p>然后当时ssm的写法是配置了一个HiddenHttpMethodFilter过滤器，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">   &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">HiddenHttpMethodFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">   &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">HiddenHttpMethodFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">   &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在form表单里面加上一个新的值，</p><p><code><input type="hidden" name="_method" value="DELETE"></code></p><p>这样在后台就知道你这个方法是个delete请求了。这是ssm里面的写法，挺有意思的是这个隐藏域的思想。然后现在SpringBoot就很简单了，直接用注解，@PutMapping，@GetMapping，这些就能直接匹配到Restful风格的请求。</p><p>以上是基础的，我这边着重想写的是啥呢，RESTful的返回值，不应该仅仅只有返回的数据，他还应该包括响应的状态码，结果描述信息，然后再是请求的结果。那这样的情况下，我们可以把这些封装起来，再搞个封装类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class AjaxResponse &#123;</span><br><span class="line"></span><br><span class="line">    private boolean isok;   //请求是否处理成功</span><br><span class="line">    private int code;          //请求响应状态码（200、400、500）</span><br><span class="line">    private String message;  //请求结果描述信息</span><br><span class="line">    private Object data;  //请求结果数据</span><br><span class="line"></span><br><span class="line">    private AjaxResponse() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static AjaxResponse success() &#123;</span><br><span class="line">        AjaxResponse resultBean = new AjaxResponse();</span><br><span class="line">        resultBean.setIsok(true);</span><br><span class="line">        resultBean.setCode(200);</span><br><span class="line">        resultBean.setMessage(&quot;success&quot;);</span><br><span class="line">        return resultBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static AjaxResponse success(Object data) &#123;</span><br><span class="line">        AjaxResponse resultBean = new AjaxResponse();</span><br><span class="line">        resultBean.setIsok(true);</span><br><span class="line">        resultBean.setCode(200);</span><br><span class="line">        resultBean.setMessage(&quot;success&quot;);</span><br><span class="line">        resultBean.setData(data);</span><br><span class="line">        return resultBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思想很有意思。其实这种思想不是第一次碰见吧，之前用pagehelper分页工具的时候，也是这个思想，把信息和分页需要的相关数据封装起来，然后向前端返回一个pageinfo的对象，再在前端解析它。</p><p>这边写这个其实意义在于，想告诉自己思路要灵活，不要死板，要熟悉各种编程思想。</p><h3 id="Dozer的使用"><a href="#Dozer的使用" class="headerlink" title="Dozer的使用"></a>Dozer的使用</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在此之前，我是没想过一个项目需要两个pojo类的。但是在接触了Dozer以后，你是能感觉到它存在的必要性的。因为你传到表现层的数据visual object (vo) ，多多少少应该和你查询出来的数据有所出入。</p><p>比如说你想用jackson去对返回的数据做个处理，比如说我id值不返回给前端，我用@JsonIgnore 排除id，那这样的标示放在po上是不合理的。所以这时候，我们就要区分po和vo。</p><h4 id="dozer是什么以及使用"><a href="#dozer是什么以及使用" class="headerlink" title="dozer是什么以及使用"></a>dozer是什么以及使用</h4><p>所以我们这边介绍dozer，它是一个能把实体和实体之间进行转换的工具，只要建立好映射关系，就像是ORM的数据库和实体映射一样。写法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EntityVo entityVo = dozerMapper.map(entity, EntityVo.class);</span><br></pre></td></tr></table></figure><p>接下来讲一下这玩意怎么配置到项目中的，首先老规矩添加依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;net.sf.dozer&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;dozer&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后创建一个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DozerBeanMapperConfigure</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Bean</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> DozerBeanMapper <span class="title">mapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           DozerBeanMapper mapper = <span class="keyword">new</span> DozerBeanMapper();</span><br><span class="line">           <span class="keyword">return</span> mapper;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以直接使用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">protected Mapper dozerMapper;</span><br></pre></td></tr></table></figure><p>具体的场景举个例子：比如说我们想要查询编号为1的员工信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Employeevo getEmployee(int id)&#123;</span><br><span class="line">  //查询到了信息，这是一个po</span><br><span class="line">Employee employee = EmployeeMapper.selectByPrimaryId(id);</span><br><span class="line">//将它转为vo</span><br><span class="line">Employeevo employeevo = dozerMapper.map(employee,Employeevo.class);</span><br><span class="line">return employeevo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那有时候我们返回的是多个对象呢，那我们就需要借助工具类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DozerUtils &#123;</span><br><span class="line"></span><br><span class="line">    static DozerBeanMapper dozerBeanMapper = new DozerBeanMapper();</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; List&lt;T&gt; mapList(Collection sourceList, Class&lt;T&gt; destinationClass)&#123;</span><br><span class="line">        List destinationList = Lists.newArrayList();</span><br><span class="line">        for (Iterator i$ = sourceList.iterator(); i$.hasNext();)&#123;</span><br><span class="line">            Object sourceObject = i$.next();</span><br><span class="line">            Object destinationObject = dozerBeanMapper.map(sourceObject, destinationClass);</span><br><span class="line">            destinationList.add(destinationObject);</span><br><span class="line">        &#125;</span><br><span class="line">        return destinationList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来个例子，比如说我们要查询所有的员工信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Employeevo&gt; getAll()&#123;</span><br><span class="line">  //查询到了信息，这是一个po</span><br><span class="line">List&lt;Employee&gt; employees = EmployeeMapper.selectByExample(null);</span><br><span class="line">//调用工具类中的mapList方法</span><br><span class="line">List&lt;Employeevo&gt; employeevos = dozerMapper.mapList(employees,Employeevo.class);</span><br><span class="line">return employeevos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样子的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Springboot第二天，又学到了很多很有意思的东西，这边来记录一下这三个比较amaze我的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="https://junshang11.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Git小结</title>
    <link href="https://junshang11.com/2019/09/26/git%E5%B0%8F%E7%BB%93/"/>
    <id>https://junshang11.com/2019/09/26/git小结/</id>
    <published>2019-09-25T16:00:00.000Z</published>
    <updated>2019-09-26T13:45:20.008Z</updated>
    
    <content type="html"><![CDATA[<p>最近超卖力地学SpringBoot，然后写很多demo。之前git不太熟，只知道add，commit，checkout这些，现在懂了更多，所以写一篇记录一下这些操作。</p><a id="more"></a><p>不讲那些我已经懂的，svn和git区别，什么本地仓库，工作区概念之类的了，直接开冲常用命令好吧。</p><h4 id="git-int"><a href="#git-int" class="headerlink" title="git int"></a>git int</h4><p>创建一个空的本地仓库</p><h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h4><p>这是将修改添加到暂存区<br>有几个后缀的</p><p>git add -A 是全部添加</p><p>git add -u 将当前目录下所有跟踪文件中被修改过或已删除文件的信息添加到索引库</p><p>通常情况下，直接是-A</p><h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><p>检查文件状态<br>在commit之前，用git status检查一下文件状态是个很好的习惯</p><h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h4><p>将更改记录(提交)到存储库<br>通常情况下写的是git commit -m’annotation’<br>加了注释的话，在log里能更直观</p><h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><p>对分支的操作<br>比如说我创建一个新的分支<br>git branch dev<br>那我就得到了一个dev的分支</p><h4 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h4><p>切换分支也可以取出误删的文件<br>比如说我<br>rm -f hello.py<br>那我就可以用<br>git checkout hello.py 把它找回来</p><h4 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h4><p>这个命令可以把两个或两个以上的开发历史加入(合并)一起<br>比如说我想把dev 这个分支 合并到master下<br>就是git checkout master 到主分支下<br>然后 git merge dev</p><h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><p>将本地的版本，推送到远程主机<br>git push origin master</p><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>取回远程主机某个分支的更新，再与本地的指定分支合并<br>它相当于先做了git fetch，然后再git merge</p><p>这些是我碰到的常用，接下来提一下cherry pick</p><h4 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry pick"></a>git cherry pick</h4><p>就比如说，我想要dev分支的某笔提交的内容，并入我目前的分支上，我不需要全部的内容，那这时候就可以用git cherry pick。那完整的流程就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git log //查看几次提交的内容</span><br><span class="line">git checkout master //回到当前的分支</span><br><span class="line">git cherry pick 20fe2f9 //将dev的20fe2f9这个分支给拿过来</span><br></pre></td></tr></table></figure><p>就是这些啦，我之前觉得git烦，现在的感觉就是，git真香啊。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近超卖力地学SpringBoot，然后写很多demo。之前git不太熟，只知道add，commit，checkout这些，现在懂了更多，所以写一篇记录一下这些操作。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Git" scheme="https://junshang11.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>lombok</title>
    <link href="https://junshang11.com/2019/09/25/lombok/"/>
    <id>https://junshang11.com/2019/09/25/lombok/</id>
    <published>2019-09-24T16:00:00.000Z</published>
    <updated>2019-09-29T03:28:00.456Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学Springboot，看教程看到了一个挺实用的工具，lombok，这边记录一下它的使用方法，和几个常用注解的含义。</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先是配置依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.16.18&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后去idea的插件库里去寻找Lombok plugin，安装重启就行了。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="Lombok作用"><a href="#Lombok作用" class="headerlink" title="Lombok作用"></a>Lombok作用</h4><p>Lombok最关键的作用是能够自动帮我们生成get/set，constructor等等。虽然这些idea能帮我们自动生成，但是只用注解就能默认生成的方式，能在阅读代码的时候更加focus在类的属性。就比如我这个bean 10几个属性，那我改了一个属性的名称，现在下面constructor，get/set方法全都要改，那不是很烦么。所以Lombok的出现，让可读性好了很多。</p><p>接下来，说明一些常用注解的方法。</p><h4 id="常用注解说明"><a href="#常用注解说明" class="headerlink" title="常用注解说明"></a>常用注解说明</h4><h6 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h6><p>提供类所有属性的 get 和 set 方法，此外还提供了equals、canEqual、hashCode、toString 方法。</p><h5 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a>@AllArgsConstructor</h5><p>为类提供一个全参的构造方法，加了这个注解后，类中不提供默认构造方法了</p><h5 id="NoArgsConstructor"><a href="#NoArgsConstructor" class="headerlink" title="@NoArgsConstructor"></a>@NoArgsConstructor</h5><p>为类提供一个无参的构造方法。</p><h5 id="NonNull"><a href="#NonNull" class="headerlink" title="@NonNull"></a>@NonNull</h5><p>注解在 属性 上，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，也会有一个默认的无参构造方法。</p><h5 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h5><p>这个是最棒的，这边写个例子。<br>比如说我一个pojo的属性是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在加上了@Builder注解后，我们在创建对象的时候，可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UserExample userExample = UserExample.builder()</span><br><span class="line">                .id(1)</span><br><span class="line">                .name(&quot;aaa&quot;)</span><br><span class="line">                .address(&quot;bbb&quot;)</span><br><span class="line">                .build();</span><br><span class="line">System.out.println(userExample);</span><br></pre></td></tr></table></figure><p>这样就可以创建出一个对象了。</p><p><strong>这边有个坑</strong></p><p>关于子类使用@Builder后，拿不到父类属性的办法。虽然我没有遇到过，但我查Lombok的使用时，很多人都反映过这个情况。这边记录一下解决办法。</p><p>首先父类需要一个全参构造方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@AllArgsConstructor</span><br><span class="line">public class Parent &#123;</span><br><span class="line">  private String a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类这边，手写一个全参构造方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Child extends Parent &#123;</span><br><span class="line">  private String b;</span><br><span class="line"></span><br><span class="line">  @Builder</span><br><span class="line">  private Child(String a, String b)&#123;</span><br><span class="line">    super(a);</span><br><span class="line">    this.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，你在创建子类的时候，就不会找不到父类的属性了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.builder().a(&quot;testA&quot;).b(&quot;testB&quot;).build();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学Springboot，看教程看到了一个挺实用的工具，lombok，这边记录一下它的使用方法，和几个常用注解的含义。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="https://junshang11.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>多线程初探</title>
    <link href="https://junshang11.com/2019/09/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%8E%A2/"/>
    <id>https://junshang11.com/2019/09/24/多线程初探/</id>
    <published>2019-09-23T16:00:00.000Z</published>
    <updated>2019-09-26T09:35:21.570Z</updated>
    
    <content type="html"><![CDATA[<p>我多线程之前3月份准备面试的时候，看过完整的马士兵老师的课，做了手抄笔记，那时候面试的时候还能答得上来，后来去了凌志，写写sql，没怎么碰都忘得差不多了，所以这篇来重新整理一下多线程相关的知识。</p><a id="more"></a><h3 id="线程的基础"><a href="#线程的基础" class="headerlink" title="线程的基础"></a>线程的基础</h3><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>首先问题就是，什么是线程什么是进程，用自己的理解的话，qq音乐app打开，这整体就是一个进程，然后打开以后检测用户登陆，开始匹配今日的最新推荐歌单，调整广告，这些都是线程。所以可以理解成是多个线程组成了一个进程，线程是最小的执行单位。</p><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><p>并发是同一时间段，多个任务都在进行。</p><p>并行是，单位时间内，多个任务同时执行。</p><p>这里面用的主要区别就是<strong>同时</strong>。</p><p>比如说双十一的前一天晚上22点10分，有些稀稀拉拉的购物狂在看不同商店里的打折商品，这是并发。并行是啥呢，双十一零点零分的时候，所有的人都在疯狂下单，这就是并行了。</p><h4 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h4><p><strong>New</strong>: 初始状态，创建了而未启动的方法</p><p><strong>Runnable</strong>： 包括两个子状态：ready和running状态，ready表示可以被调用了，running是正在运行。</p><p><strong>Blocked</strong>：一个线程发起了一个阻塞式I/O操作后，或者申请到了一个由其他线程持有的独占资源时，线程就会进入这个状态，也就是说想申请资源，结果被堵了。等拿到了资源，就又可以转为runnable了。</p><p><strong>Waiting</strong>：等待状态，线程不急着办事情，给人让路</p><p><strong>Timed_Waiting</strong>：也是等待，和waiting的区别在于，他是有时间限制的等待，时间限制后，直接进入runnable状态</p><p><strong>Terminated</strong>：结束了，线程使命完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我多线程之前3月份准备面试的时候，看过完整的马士兵老师的课，做了手抄笔记，那时候面试的时候还能答得上来，后来去了凌志，写写sql，没怎么碰都忘得差不多了，所以这篇来重新整理一下多线程相关的知识。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="多线程" scheme="https://junshang11.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>websocket的实现</title>
    <link href="https://junshang11.com/2019/09/22/websocket%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://junshang11.com/2019/09/22/websocket的实现/</id>
    <published>2019-09-21T16:00:00.000Z</published>
    <updated>2019-09-23T09:01:09.561Z</updated>
    
    <content type="html"><![CDATA[<p>周六家里有事，中午和我妈在饭店吃饭，看到一个挺有趣的点餐机制。扫码点餐，但是我在我这个界面点餐，我妈的手机立马就会更新最新的我点的东西。很好奇这么快的响应速度是怎么做到的，查了一些资料，得出的结论是用websocket实现的，然后周末就来写写看这个东西的原理是啥，是怎么实现的。</p><a id="more"></a><h3 id="websocket是什么"><a href="#websocket是什么" class="headerlink" title="websocket是什么"></a>websocket是什么</h3><pre>WebSocket 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯，它建立在 TCP 之上，同 HTTP 一样通过 TCP 来传输数据。</pre><p>传统的http请求客户端模式是什么呢，这边用IBM开发者社区的图来表示：</p><p><img src="/images/websocket/1.png" alt="传统http请求客户端模式"></p><p>而websocket的模式是：</p><p><img src="/images/websocket/2.png" alt="websocket模式"></p><p>可以看到websocket是类似 Socket 的 TCP 长连接的通讯模式，一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。这样的模式可见的优点是他很快，在断开连接之前，不需要重复发出请求，这样的模式能极大地节省网络带宽资源的消耗，以及它具有实时性，因此它能够实现我遇到的那种点单模式。</p><h3 id="实现一个简单的websocket"><a href="#实现一个简单的websocket" class="headerlink" title="实现一个简单的websocket"></a>实现一个简单的websocket</h3><p>WebSocket 的实现分为客户端和服务端两部分，客户端（通常为浏览器）发出 WebSocket 连接请求，服务端响应，实现类似 TCP 握手的动作，从而在浏览器客户端和 WebSocket 服务端之间形成一条 HTTP 长连接快速通道。两者之间后续进行直接的数据互相传送，不再需要发起连接和相应。</p><p>先看服务端，首先导入依赖，</p><pre></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.0&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在这个包中就有我们所需要的javax.websocket.*的 API。</p><p>然后开始写测试类，websocket的流程在于，使用@ServerEndpoint(     ) 作为服务器端的注解，注解的值被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端。</p><p>然后我们需要用concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。然后我们需要创建一个session对象，来存储对话。完整的服务器端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ServerEndpoint</span> 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端,</span></span><br><span class="line"><span class="comment"> * 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/websocket"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> onlineCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。若要实现服务端与单一客户端通信的话，可以使用Map来存放，其中Key可以为用户标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketTest&gt; webSocketSet = <span class="keyword">new</span> CopyOnWriteArraySet&lt;WebSocketTest&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session  可选的参数。session为与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        webSocketSet.add(<span class="keyword">this</span>);     <span class="comment">//加入set中</span></span><br><span class="line">        addOnlineCount();           <span class="comment">//在线数加1</span></span><br><span class="line">        System.out.println(<span class="string">"有新连接加入！当前在线人数为"</span> + getOnlineCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        webSocketSet.remove(<span class="keyword">this</span>);  <span class="comment">//从set中删除</span></span><br><span class="line">        subOnlineCount();           <span class="comment">//在线数减1</span></span><br><span class="line">        System.out.println(<span class="string">"有一连接关闭！当前在线人数为"</span> + getOnlineCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 可选的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"来自客户端的消息:"</span> + message);</span><br><span class="line">        <span class="comment">//群发消息</span></span><br><span class="line">        <span class="keyword">for</span>(WebSocketTest item: webSocketSet)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                item.sendMessage(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生错误时调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable error)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发生错误"</span>);</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法与上面几个方法不一样。没有用注解，是根据自己需要添加的方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">        <span class="comment">//this.session.getAsyncRemote().sendText(message);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onlineCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketTest.onlineCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketTest.onlineCount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端代码如上，接下来我们编写客户端代码，通常客户端就是浏览器端，而如今绝大多数浏览器都已经支持websocket，所以我们直接写js代码。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> pageEncoding=<span class="string">"UTF-8"</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Java后端WebSocket的Tomcat实现&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">Welcome&lt;br/&gt;&lt;input id=<span class="string">"text"</span> type=<span class="string">"text"</span>/&gt;</span><br><span class="line">&lt;button onclick="send()"&gt;发送消息&lt;/button&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;button onclick="closeWebSocket()"&gt;关闭WebSocket连接&lt;/button&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;div id="message"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> websocket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//判断当前浏览器是否支持WebSocket</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'WebSocket'</span> in window) &#123;</span><br><span class="line">        websocket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:8080/websocket"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'当前浏览器 Not support websocket'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接发生错误的回调方法</span></span><br><span class="line">    websocket.onerror = function () &#123;</span><br><span class="line">        setMessageInnerHTML(<span class="string">"WebSocket连接发生错误"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接成功建立的回调方法</span></span><br><span class="line">    websocket.onopen = function () &#123;</span><br><span class="line">        setMessageInnerHTML(<span class="string">"WebSocket连接成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收到消息的回调方法</span></span><br><span class="line">    websocket.onmessage = function (event) &#123;</span><br><span class="line">        setMessageInnerHTML(event.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接关闭的回调方法</span></span><br><span class="line">    websocket.onclose = function () &#123;</span><br><span class="line">        setMessageInnerHTML(<span class="string">"WebSocket连接关闭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。</span></span><br><span class="line">    window.onbeforeunload = function () &#123;</span><br><span class="line">        closeWebSocket();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将消息显示在网页上</span></span><br><span class="line">    <span class="function">function <span class="title">setMessageInnerHTML</span><span class="params">(innerHTML)</span> </span>&#123;</span><br><span class="line">        document.getElementById(<span class="string">'message'</span>).innerHTML += innerHTML + <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭WebSocket连接</span></span><br><span class="line">    <span class="function">function <span class="title">closeWebSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        websocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="function">function <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> message = document.getElementById(<span class="string">'text'</span>).value;</span><br><span class="line">        websocket.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这样，当两个不同的客户端，对ws://localhost:8080/websocket，发出请求时，这样他们就进入了同一个session中，这样他们就能进行相互的对话了。</p><p>效果如图所示：</p><p>A点了红烧狮子头，这时B的客户端就能直接看到A点了狮子头</p><p><img src="/images/websocket/3.png" alt="效果图"></p><p>在B点了水煮肉片时，A的界面也能立刻出现水煮肉片的选项。</p><p><img src="/images/websocket/3.png" alt="效果图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周六家里有事，中午和我妈在饭店吃饭，看到一个挺有趣的点餐机制。扫码点餐，但是我在我这个界面点餐，我妈的手机立马就会更新最新的我点的东西。很好奇这么快的响应速度是怎么做到的，查了一些资料，得出的结论是用websocket实现的，然后周末就来写写看这个东西的原理是啥，是怎么实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="websocket" scheme="https://junshang11.com/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>Java经典面试题总结</title>
    <link href="https://junshang11.com/2019/09/19/Java%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://junshang11.com/2019/09/19/Java经典面试题/</id>
    <published>2019-09-18T16:00:00.000Z</published>
    <updated>2019-09-23T02:27:03.700Z</updated>
    
    <content type="html"><![CDATA[<p>这篇记一些我比较容易搞混的概念还有题目，尽量用自己的语言去表达出来，因为只有自己语言表达出来才是真的理解了吧。</p><a id="more"></a><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try catch finally"></a>try catch finally</h3><p>之前看过一个题目讲，如果try和finally里都有return，那么它的执行顺序是什么？</p><pre><code>try{ return; }    catch(){}     finally{}     return;</code></pre><p>他会先执行try块中return之前的语句，再到finally块，然后去try中的return。</p><p>然后还有种情况：</p><pre><code>try{ return; }    catch(){}     finally{return}     </code></pre><p>他会先执行try块中return之前的语句，再到finally这边，因为finally中有return，所以他会return后提前跳出。</p><p>所以结论是：<br>finally里的语句一定会执行，所以不建议在finally语句里加入return，因为会提前跳出，返回值不是try或者catch块里的返回值。</p><h3 id="equals-的那些事"><a href="#equals-的那些事" class="headerlink" title="equals, ==的那些事"></a>equals, ==的那些事</h3><p>== 一直是比较两个对象的地址是不是相等的，即两个对象是不是同一个对象。基本类型是比较值是否相同，引用类型是地址是否相同。</p><p>equals ，类如果没有覆盖equals方法，则通过equsls比较两个对象时，等价于通过”==”比较这两个对象，如果覆盖了，比如说string里的equals，那就是比较两个对象的值。</p><p>这里还有一个题目，</p><h4 id="为啥重写equals必须重写hashcode-方法？"><a href="#为啥重写equals必须重写hashcode-方法？" class="headerlink" title="为啥重写equals必须重写hashcode()方法？"></a>为啥重写equals必须重写hashcode()方法？</h4><p>任何类都具有自己的hashcode。</p><pre>如果两个对象相等，那么他们的hashcode一定是相同的；如果两个对象相等，那么两个对象调用equals方法都返回true；如果两个对象hashcode相同，那么两个对象可能equals不同（概率性问题）因此我们可以得出结论，如果说两个对象equals，那么他们的hashcode方法一定是相同的，所以如果equals重写了，hashcode()方法必定重写。</pre><p>这一篇记得是Java基础的问题，下一篇写多线程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇记一些我比较容易搞混的概念还有题目，尽量用自己的语言去表达出来，因为只有自己语言表达出来才是真的理解了吧。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试" scheme="https://junshang11.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>svn知识补全</title>
    <link href="https://junshang11.com/2019/09/10/svn/"/>
    <id>https://junshang11.com/2019/09/10/svn/</id>
    <published>2019-09-09T16:00:00.000Z</published>
    <updated>2019-09-29T03:28:04.193Z</updated>
    
    <content type="html"><![CDATA[<p>因为看到南通很多公司都用svn作为代码版本控制系统，而我之前用得多的是git吧。所以这篇学一下svn的基本操作，这样子面试遇到了也是有点准备的那种。</p><a id="more"></a><p>整体来说，svn和git还是有点像的。</p><h3 id="svn的生命周期"><a href="#svn的生命周期" class="headerlink" title="svn的生命周期"></a>svn的生命周期</h3><pre>创建版本库，检出checkout，更新update，执行变更 对文件内容的修改，复查变化status，重置修改revert，解决冲突merge，提交更改 commit</pre><p>因为Mac有自带的svn，直接terminal里输入svn help可以看到我的版本是1.10.3</p><ol><li><p>将文件checkout到本地</p><p>svn checkout path (path是服务器上的目录)</p><p>checkout这步就有点像git里的git add，将服务器的内容拉到本地做一个个人的工作空间</p></li></ol><ol start="2"><li><p>往版本库中添加新的文件</p><p>svn add file</p><p>比如说我svn add test.java</p></li></ol><ol start="3"><li><p>将改动的文件提交到版本库</p><p>svn commit -m “LogMessage“ [-N] [<em>–no-unlock] PATH</em></p></li></ol><ol start="4"><li><p>比较差异</p><p>svn diff path（将修改的文件与基础版本比较）</p></li></ol><ol start="5"><li>将两个版本之前的差异合并到当前文件<br>svn merge -r m:n path</li></ol><ol start="6"><li>查看文件或者目录状态<br>svn status path(目录下的文件和子目录的状态，正常状态不显示)<br>其中可能出现的参数：M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定</li></ol><ol start="7"><li>删除文件<br>svn delete path -m “delete test fle“</li></ol><ol start="8"><li><p>版本回退</p><p>svn revert file</p></li></ol><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为看到南通很多公司都用svn作为代码版本控制系统，而我之前用得多的是git吧。所以这篇学一下svn的基本操作，这样子面试遇到了也是有点准备的那种。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://junshang11.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化</title>
    <link href="https://junshang11.com/2019/09/01/SQL%E4%BC%98%E5%8C%96/"/>
    <id>https://junshang11.com/2019/09/01/SQL优化/</id>
    <published>2019-08-31T16:00:00.000Z</published>
    <updated>2019-09-17T08:21:25.506Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在最前面的"><a href="#写在最前面的" class="headerlink" title="写在最前面的"></a>写在最前面的</h3><p>说实话，真的没想到凌志是能这么玩的，强制转cobol，不然就进不了岗。我挺懵逼的，明明招进来的时候很明确地说了写java的啊。歇了两天，很认真地思考了一下以后的职业发展方向，还是不能接受转语言，周五选择离职应该是正确的决定。</p><p>我现在在想我过去的这两个月，自己所做的事情，有没有浪费时间。想了想，其实感觉也还好，最近真的看了很多数据库相关的东西，虽然没有涉及到那些高阶的，比如说分库分表之类的，但SQL整体的知识，索引的原理，一些sql优化的方向，这些知识是自己学到手了的。这边记录一下我笔记本上记录过的一些SQL优化的方法。</p><a id="more"></a><h3 id="一些基础的优化"><a href="#一些基础的优化" class="headerlink" title="一些基础的优化"></a>一些基础的优化</h3><h4 id="lt-gt-优化"><a href="#lt-gt-优化" class="headerlink" title="&lt;&gt;优化"></a>&lt;&gt;优化</h4><p>不等号通常不能走索引，通常情况下用union连接起来。比如说我这边检索出所有金额不等于100的订单，优化的语句就是</p><pre><code>select id from orders where amount >100）union all(select id from orders where amount <100 and amount>0);</100></code></pre><h4 id="OR优化"><a href="#OR优化" class="headerlink" title="OR优化"></a>OR优化</h4><p>or是无法使用联合索引的，比如说我要选出电话号码等于1111或者用户编号是11的用户姓名，就该用union来连接起来。</p><pre><code>(select username from users where mobile = '1111'union(select username from users where id = 11);</code></pre><pre>这边记录一下,union和union all的区别，union是会压缩重复的值，union all并不会</pre><h4 id="in-优化"><a href="#in-优化" class="headerlink" title="in 优化"></a>in 优化</h4><p>之前我记过，in适合主表大，字表小的情况，exist适合主表小子表大的情况，但不管怎么说都是子查询，这种偏嵌套的运行效率都不怎么高，应该尽量用left join来表示,我们这边举个例子是，找出身份是vip的人的用户的单号，涉及到两张表，user表和order表，我们来用left join写一下。</p><pre><code>select o.id from orders o left join user uon o.user_id = u.id where u.class = 'VIP';</code></pre><h4 id="几个不要"><a href="#几个不要" class="headerlink" title="几个不要"></a>几个不要</h4><ol><li>我前面索引那篇写过，不要对索引的数据进行任何计算，不然都会让索引失效。</li><li>不要用select *，这样子一定会走全表扫描，好好写表中的列</li><li>join虽然好，但不要连接超过三个以上的表。</li></ol><h4 id="如何发现需要优化的语句"><a href="#如何发现需要优化的语句" class="headerlink" title="如何发现需要优化的语句"></a>如何发现需要优化的语句</h4><h5 id="打开慢查询日志"><a href="#打开慢查询日志" class="headerlink" title="打开慢查询日志"></a>打开慢查询日志</h5><p>首先打开慢查询日志<br><code>set global slow_query_log='ON';</code><br>再次查看是否开启<br><code>show variables like'%slow_query_log';</code><br>设置时间的阀值<br><code>set global long_query_time = 3;</code></p><p>这样我们就设置好了阀值是3秒钟。</p><p>接下来要是查询语句超过了3秒，MySQL会自动地记录到慢查询日志中。我在我的mac上遇到的问题是，我找不到这个慢查询日志的地址，查了文档，我们可以使用</p><p><code>SELECT @@slow_query_log_file;</code></p><p>找到他。</p><h5 id="用Explain查看执行计划"><a href="#用Explain查看执行计划" class="headerlink" title="用Explain查看执行计划"></a>用Explain查看执行计划</h5><p>用这个对查询是否命中索引非常有用。</p><p>用我这边有的一个范例库nba举个例子</p><p><code>select player_name,  team_name from player  left join team  on player.team_id = team.team_id;</code></p><p>用explain看一下，这个的结果是：</p><p><img src="/images/SQL%E4%BC%98%E5%8C%96/1.png" alt="Explain"></p><p>在这么多参数中，我们主要关注的是type列，type列的几种情况是：</p><p><img src="/images/SQL%E4%BC%98%E5%8C%96/2.png" alt="Explain"></p><p>效率从低到高依次为 all &lt; index &lt; range &lt; index_merge &lt; ref &lt; eq_ref &lt; const/system，我们希望执行计划至少可以使用到range级别，如果看到了all和index，就需要去从SQL语句和索引设计的角度上进行改进。</p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在最前面的&quot;&gt;&lt;a href=&quot;#写在最前面的&quot; class=&quot;headerlink&quot; title=&quot;写在最前面的&quot;&gt;&lt;/a&gt;写在最前面的&lt;/h3&gt;&lt;p&gt;说实话，真的没想到凌志是能这么玩的，强制转cobol，不然就进不了岗。我挺懵逼的，明明招进来的时候很明确地说了写java的啊。歇了两天，很认真地思考了一下以后的职业发展方向，还是不能接受转语言，周五选择离职应该是正确的决定。&lt;/p&gt;
&lt;p&gt;我现在在想我过去的这两个月，自己所做的事情，有没有浪费时间。想了想，其实感觉也还好，最近真的看了很多数据库相关的东西，虽然没有涉及到那些高阶的，比如说分库分表之类的，但SQL整体的知识，索引的原理，一些sql优化的方向，这些知识是自己学到手了的。这边记录一下我笔记本上记录过的一些SQL优化的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MySQL" scheme="https://junshang11.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL经典实例1</title>
    <link href="https://junshang11.com/2019/08/24/SQL%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B1/"/>
    <id>https://junshang11.com/2019/08/24/SQL经典实例1/</id>
    <published>2019-08-23T16:00:00.000Z</published>
    <updated>2019-09-15T07:34:52.786Z</updated>
    
    <content type="html"><![CDATA[<p>这是我最近找到的一本很棒的关于SQL的书，里面记录了150多个SQL常见问题和解决方法，最近做了挺久的sql优化，感觉自己还是蛮熟练的了，结果看到这本是真的被amaze了一下。复杂场景下，sql得会写才有机会优化吧，这本书追了追了。</p> <a id="more"></a><h3 id="1-SQL中使用条件逻辑"><a href="#1-SQL中使用条件逻辑" class="headerlink" title="1.SQL中使用条件逻辑"></a>1.SQL中使用条件逻辑</h3><p>case函数的使用</p><pre><code>Select ename,sal,    case when sal<=2000 then ‘underpaid’ when sal>= 4000 then ‘underpaid’        else’ok'    End as statusfrom emp</=2000></code></pre><p>记录一下case函数的用法</p><pre><code>case when value then statement      else ’statement'end case;</code></pre><h3 id="2-把null值转换为实际值"><a href="#2-把null值转换为实际值" class="headerlink" title="2.把null值转换为实际值"></a>2.把null值转换为实际值</h3><p>有两个函数可以用<br>coalesce，返回的是参数列表里的第一个非null值。</p><p><code>select coalesce(comm,0) from emp;</code></p><p>或者用case函数</p><pre><code>select case         when comm is not null then comm        else 0         endFrom emp;</code></pre><h3 id="3-排序时对null值的处理"><a href="#3-排序时对null值的处理" class="headerlink" title="3.排序时对null值的处理"></a>3.排序时对null值的处理</h3><p>想把所有不为null的数放到排序的前面</p><pre><code>select ename,sal,comm    from(select ename,sal,comm,          case when comm is null then 0 else 1 end as is_null from emp)xorder by is_null desc, comm</code></pre><h3 id="4-union-和-union-all的区别"><a href="#4-union-和-union-all的区别" class="headerlink" title="4.union 和 union all的区别"></a>4.union 和 union all的区别</h3><p><em>union等同于针对union all的输出结果再执行一次distinct操作</em></p><h3 id="5-查询编号为10的部门的总工资和总奖金"><a href="#5-查询编号为10的部门的总工资和总奖金" class="headerlink" title="5.查询编号为10的部门的总工资和总奖金"></a>5.查询编号为10的部门的总工资和总奖金</h3><p>因为部分员工获得了不只一次奖金，所以这边有两种方法可以把重复项目给清除</p><p>一种是在聚合函数之前，用关键字distinct</p><p>另一种是，在进行连接查询之前执行聚合运算</p><pre><code>select deptno,        sum(distinct sal) as total_sal,        sum(bonus) as total_bonusfrom(    select e.empno,        e.ename,        e.sal,        e.deptno,        e.sal*case when eb.type = 1 then .1                    when eb.type =2 then .2                end as bonus    from emp e, emp_bonus eb    where e.empno = eb.empno and e.deptno = 10)x group by deptno;</code></pre><p><em>group by函数通常和聚合函数一起用，having的使用是因为，where不能和聚合函数（sum）一起使用</em></p><h3 id="6-上一题的拓展"><a href="#6-上一题的拓展" class="headerlink" title="6.上一题的拓展"></a>6.上一题的拓展</h3><p> 如果只是部分人获得了奖励，就需要left join，将没获得奖金的人的工资也算进来</p><h3 id="7-full-join是left-join和right-join的并集"><a href="#7-full-join是left-join和right-join的并集" class="headerlink" title="7.full join是left join和right join的并集"></a>7.full join是left join和right join的并集</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我最近找到的一本很棒的关于SQL的书，里面记录了150多个SQL常见问题和解决方法，最近做了挺久的sql优化，感觉自己还是蛮熟练的了，结果看到这本是真的被amaze了一下。复杂场景下，sql得会写才有机会优化吧，这本书追了追了。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MySQL" scheme="https://junshang11.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>关于索引</title>
    <link href="https://junshang11.com/2019/08/13/%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95/"/>
    <id>https://junshang11.com/2019/08/13/关于索引/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2019-09-15T07:11:42.378Z</updated>
    
    <content type="html"><![CDATA[<p>昨天碰到一个索引需要优化，翻了挺多资料，琢磨着得整一篇全的讲讲索引的知识点。</p> <a id="more"></a><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p> 我的理解就是书的目录，对数据进行定位和查找，速度极快。那既然是目录，问题就是，如果我数据更改的频次很高，比如说添加删除等，那这个目录就是得频繁的修改。这也是索引的特性，对于需要经常进行修改的表，我们并不添加索引。索引的添加语句是：</p><p> <code>CREATE UNIQUE INDEX index_name ON table_name (column_name) ;</code></p><h3 id="索引的种类"><a href="#索引的种类" class="headerlink" title="索引的种类"></a>索引的种类</h3><h4 id="从功能逻辑上来说"><a href="#从功能逻辑上来说" class="headerlink" title="从功能逻辑上来说"></a>从功能逻辑上来说</h4><p><em>普通索引</em>:没有任何约束,基础索引</p><p>_唯一索引_：在基础索引的基础上添加了数据唯一性的约束</p><p>_主键索引_：在唯一索引的基础上添加了不为空</p><p>_全文索引_：用的不多</p><p>（这种一步一步约束提升的样子有点像数据库设计三范式。。</p><h4 id="从物理实现上来分"><a href="#从物理实现上来分" class="headerlink" title="从物理实现上来分"></a>从物理实现上来分</h4><p>_聚集索引_：按照主键来排序存储数据</p><p>_非聚集索引_：会有单独的存储空间存放非聚集索引，这些索引项是按照顺序存储的，但索引项指向的内容是随机存储的，也就是说查询得分两步骤，先找到索引，再通过索引找到存储的数据。</p><p><strong>通常情况下，聚集索引比非聚集索引效率更高一点</strong></p><h4 id="按照字段个数划分"><a href="#按照字段个数划分" class="headerlink" title="按照字段个数划分"></a>按照字段个数划分</h4><p>_单一索引_：索引列为一列时</p><p>_联合索引_：索引列为多列时<br>创建联合索引的语句</p><p><code>create index 索引名 on 表名（字段名1，字段名2）</code></p><p>对于联合索引来说，有最左匹配原则。</p><h3 id="索引为啥默认采用b-树作为存储的数据结构"><a href="#索引为啥默认采用b-树作为存储的数据结构" class="headerlink" title="索引为啥默认采用b+树作为存储的数据结构"></a>索引为啥默认采用b+树作为存储的数据结构</h3><p>整理了一张图，很直接了。</p><p><img src="/images/%E7%B4%A2%E5%BC%95/b+%E6%A0%91.png" alt="索引数据结构"></p><h3 id="索引的使用原则"><a href="#索引的使用原则" class="headerlink" title="索引的使用原则"></a>索引的使用原则</h3><h4 id="啥时候创建索引呢"><a href="#啥时候创建索引呢" class="headerlink" title="啥时候创建索引呢"></a>啥时候创建索引呢</h4><ol><li>字段的数值有唯一性的限制</li><li>频繁作为 WHERE 查询条件的字段</li><li>需要经常 GROUP BY 和 ORDER BY 的列 </li><li>UPDATE、DELETE 的 WHERE 条件列，一般也需要创建索引</li><li>DISTINCT 字段需要创建索引</li></ol><h4 id="哪些情况下索引会失效"><a href="#哪些情况下索引会失效" class="headerlink" title="哪些情况下索引会失效"></a>哪些情况下索引会失效</h4><ol><li>如果索引进行了表达式计算，则会失效 </li><li>如果对索引使用函数，也会造成失效 （比如说我substring一下）</li><li>在 WHERE 子句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引，那么索引会失效</li><li>当我们使用 LIKE 进行模糊查询的时候，后面不能是 %（这边有个有意思的，%123不行，但是123%是能走索引的）</li><li>索引列与 NULL 或者 NOT NULL 进行判断的时候也会失效。</li><li>索引列与 NULL 或者 NOT NULL 进行判断的时候也会失效。（所以我们设计表的时候，最好都加上not null的约束）</li></ol><p>以上是我参考了SQL必知必会和一些csdn的blog总结的索引相关知识。总感觉对SQL这块，还得再写一篇关于SQL调优才行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天碰到一个索引需要优化，翻了挺多资料，琢磨着得整一篇全的讲讲索引的知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SQL" scheme="https://junshang11.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL必知必会学到的</title>
    <link href="https://junshang11.com/2019/07/13/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <id>https://junshang11.com/2019/07/13/SQL必知必会/</id>
    <published>2019-07-12T16:00:00.000Z</published>
    <updated>2019-09-05T10:02:36.893Z</updated>
    
    <content type="html"><![CDATA[<p>因为现在培训时期没有机会接触业务代码，所以就是做一些SQL优化的事情，然后遇到一些之前没有学过的SQL写法，比如说判断啊之类的，然后就买了“极客时间的SQL必知必会”的课，是真的不错，所以这边再开一篇，记录一下自己学到的新的写法。</p> <a id="more"></a><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>   utf8_general_ci 对大小写不敏感。 Utf8_bin是敏感的。</p><h3 id="2-设计数据库表的经典“三少一多”原则"><a href="#2-设计数据库表的经典“三少一多”原则" class="headerlink" title="2 设计数据库表的经典“三少一多”原则"></a>2 设计数据库表的经典“三少一多”原则</h3><ol><li>数据表个数越少越好</li><li>字段个数越少越好</li><li>联合主键字段个数越少越好</li><li>使用的主键和外键越多越好（提升相互之间的关联使用率）</li></ol><h3 id="3-查询常数"><a href="#3-查询常数" class="headerlink" title="3 查询常数"></a>3 查询常数</h3><p><code>Select ‘农药’ as platform, name from heroes;</code></p><h3 id="4-去重用的distinct，必须写在sql语句的最前面"><a href="#4-去重用的distinct，必须写在sql语句的最前面" class="headerlink" title="4 去重用的distinct，必须写在sql语句的最前面"></a>4 去重用的distinct，必须写在sql语句的最前面</h3><p><code>Select distinct name, age from users;</code></p><h3 id="5-百分比的表示"><a href="#5-百分比的表示" class="headerlink" title="5 百分比的表示"></a>5 百分比的表示</h3><p><code>Select concat(round(mp.max/mp.base,2)*100, ,’%');</code></p><h3 id="6-表创建相关"><a href="#6-表创建相关" class="headerlink" title="6 表创建相关"></a>6 表创建相关</h3><p>有时候为了防止删除关联表，就可以使用外键约束。<br><code>Set foreign_key_checks =1;</code><br>这样删除表的时候，就会报出 “a foreign key constraint fail”。</p><p>存储中文信息的时候，表头创建加一句<br><code>SET NAMES utf8mb4;</code><br>Utf8支持的最大字符长度是3个字节，所有4个字节的宽数据就存储不了，这时候就得改成utf8mb4</p><h3 id="7-where-和-having的区别"><a href="#7-where-和-having的区别" class="headerlink" title="7 where 和 having的区别"></a>7 where 和 having的区别</h3><p>where 是对数据的过滤，having是针对分组的</p><h3 id="8-子查询-any，all的用法"><a href="#8-子查询-any，all的用法" class="headerlink" title="8 子查询 any，all的用法"></a>8 子查询 any，all的用法</h3><p>select name, height from players where height &gt; any(select height from player where team_id = 1002);</p><h3 id="9-子查询什么时候用exists，什么时候用in"><a href="#9-子查询什么时候用exists，什么时候用in" class="headerlink" title="9 子查询什么时候用exists，什么时候用in"></a>9 子查询什么时候用exists，什么时候用in</h3><p>当查询字段进行了索引时，主表 A 大于从表 B，使用 IN 子查询效率更高；<br>相反主表 A 小于从表 B 时，使用 EXISTS 子查询效率更高。</p><p><strong>虽然是这么说，但是真的少用子查询好吧，因为效率真的不高</strong></p><h3 id="10-连接查询"><a href="#10-连接查询" class="headerlink" title="10 连接查询"></a>10 连接查询</h3><p>内连接<br>左外<br>右外<br>自连接</p><p>例子：三支球队比赛，列出所有的可能对阵表<br><code>Select t1.name, t2.name from team as t1 left join team as t2 on t1.id <> t2.id;</code></p><h3 id="11-视图"><a href="#11-视图" class="headerlink" title="11 视图"></a>11 视图</h3><pre><code>create view player_above_avg_height as Select player.id, height From player Where height > (select avg(height) from player)</code></pre><p>我查看了视图和临时表的区别，我还是挺好奇，视图在实际开发中，到底被用在哪里的。</p><h3 id="12-存储过程"><a href="#12-存储过程" class="headerlink" title="12 存储过程"></a>12 存储过程</h3><pre><code>CREATE PROCEDURE `add_num`(IN n INT)BEGINDECLARE i INT;DECLARE sum INT;SET i = 1;SET sum = 0;WHILE i <= n do set sum="sum" + i; i="i" +1; end while; select sum; < code></=></code></pre><p>NaviCat写法，如果在mysql命令行里面，得在两端加上DELIMITER // 结尾DELIMITER;。</p><p>存储过程的三种参数类型（in，out, inout)</p><pre><code>CREATE PROCEDURE `get_hero_scores`(OUT max_max_hp FLOAT,OUT min_max_mp FLOAT,OUT avg_max_attack FLOAT,s VARCHAR(255))BEGINSELECT MAX(hp_max), MIN(mp_max), AVG(attack_max) FROM heros WHERE role_main = s INTO max_max_hp, min_max_mp, avg_max_attack;END</code></pre><p>这边有个select… into的用法，将取到的值赋给out的数据，方便他传出来。</p><p>例题：</p><pre><code>CREATE PROCEDURE 'total_hp' ( OUT sum_hp_max FLOAT, IN s VARCHAR ( 255 ) ) BEGIN    SELECT        SUM( hp_max ) AS sum_hp_max     FROM        heros     WHERE        role_main = s INTO sum_hp_max;END CALL total_hp ( @sum_hp_max, '射手' );SELECT @sum_hp_max</code></pre><h3 id="13-事务隔离级别"><a href="#13-事务隔离级别" class="headerlink" title="13 事务隔离级别"></a>13 事务隔离级别</h3><pre>常见的错误*脏读：A读到了B没提交的事务**不可重复读：A两次查询得到两个不同的结尾**幻读：A第一次读和第二次读获得的数据不一（B事务对数据做出了修改）*</pre><p>四种隔离级别：<br><img src="/images/isolation_level.jpg" alt="四种隔离级别" title="四种隔离级别"></p><p>MySQL是不可重复读。</p><h3 id="14-游标"><a href="#14-游标" class="headerlink" title="14 游标"></a>14 游标</h3><p>游标实际上是一种控制数据集的更加灵活的处理方式。<br>DECLARE cursor_name CURSOR FOR select_statement;</p><p>例子：</p><pre><code>DECLARE cur_hero CURSOR FOR SELECT hp_max FROM heros;OPEN cursor_name;FETCH cursor_name INTO var_name;CLOSE cursor_name;DEALLOCATE PREPARE;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为现在培训时期没有机会接触业务代码，所以就是做一些SQL优化的事情，然后遇到一些之前没有学过的SQL写法，比如说判断啊之类的，然后就买了“极客时间的SQL必知必会”的课，是真的不错，所以这边再开一篇，记录一下自己学到的新的写法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SQL" scheme="https://junshang11.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL Cheatsheet</title>
    <link href="https://junshang11.com/2019/03/13/SQL%20Cheatsheet/"/>
    <id>https://junshang11.com/2019/03/13/SQL Cheatsheet/</id>
    <published>2019-03-12T16:00:00.000Z</published>
    <updated>2019-09-05T12:48:04.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL语句集合"><a href="#SQL语句集合" class="headerlink" title="SQL语句集合"></a>SQL语句集合</h3><p>这篇是用来记录我之前忘记的好多SQL语句的，因为有些SQL语句真的是不常用就会忘记的，记到这边来下次写SQL的时候可以看。</p> <a id="more"></a><h3 id="皮一下"><a href="#皮一下" class="headerlink" title="皮一下"></a>皮一下</h3><p>开篇先来皮一下，因为真的好几次忘记了自己的密码是什么，然后去网上找那些改密码的方法。所以干脆这边就记录一下。</p><p>先把MySQL服务关闭。</p><p><code>sudo /usr/local/mysql/support-files/mysql.server stop</code></p><p>然后进入mysql的bin目录。<code>cd /usr/local/mysql/bin</code>。</p><p>绕过用户验证。<code>mysqld --skip-grant-tables</code></p><p>重新开一个命令行，直接进mysql。</p><p><code>set password for 'root'@'localhost'=password('xxx');</code></p><p>这样子新的密码就修改好了。如果你需要修改原来的老密码，用的是</p><p><code>update user set password=password('123456') where user='root';</code></p><h3 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h3><p>创建数据库的</p><pre><code>DROP TABLE IF EXISTS admin;CREATE TABLE admin (  username varchar(20) NOT NULL DEFAULT '',  password varchar(32) DEFAULT NULL,  PRIMARY KEY ('username')) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><p>创建表的</p><pre><code>DROP TABLE IF EXISTS t_stu;CREATE Table t_stu(        stuId int(11) NOT NULL AUTO_INCREMENT,          stuName varchar(20) NOT NULL,          PRIMARY KEY(stuId) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p>修改表的（增加，删除列）</p><p><code>ALTER TABLE t_student ADD col char(20);</code></p><p><code>ALTER TABLE 't_student' DROP COLUMN col;</code></p><p>删除表</p><p><code>DROP TABLE table;</code></p><h4 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h4><p>插入</p><p><code>INSERT INTO table (col1,col2) VALUES(val1,val2); </code></p><p>插入检索出来的数据</p><pre><code>INSERT INTO table(col1,col2) SELECT * FROM table2;</code></pre><p>更新语句</p><pre><code>UPDATE table1SET col = valWHERE id = 1;</code></pre><p>删除语句</p><pre><code>DELETE FROM table WHERE id =1;</code></pre><p>清空表</p><p><code>TRUNCATE TABLE table； </code></p><p><em>TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。</em></p><p>查询语句实在是有点多，一些常用的我不会忘的就不记了，写点我容易忘的</p><p>通配符的用法</p><pre><code>SELECT * FROM tableWHERE col LIKE '[^AB]%';-- ^否定，[]集合，匹配其中之一，%匹配多个字符，_匹配一个字符</code></pre><p>连接字段</p><pre><code>SELECT CONCAT(TRIM(col),'('TRIM(col2),')')FROM student;</code></pre><p>日期计算记一个日期之差的把</p><p><code>SELECT DATEDIFF('2007-12-31','2007-12-30'); </code></p><p>接下来就是比较难的部分了：</p><p><strong>分组是将具有相同的数据值的行放在同一组中</strong></p><pre><code>SELECT col, COUNT(*) AS numFROM tableGROUP BY col</code></pre><p><em>这里记一下，where是过滤行的，having是过滤分组的，group by默认出现在where之后，order by之前</em></p><p>子查询就不记了吧，因为效率是真的低，一般来说子查询都能用连接查询替代，所以接下来用一张神图来概括所有的连接查询。</p><p><img src="/images/sql_join.jpg" alt="join神图" title="连接的写法"></p><p>大概常用的就是这些了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SQL语句集合&quot;&gt;&lt;a href=&quot;#SQL语句集合&quot; class=&quot;headerlink&quot; title=&quot;SQL语句集合&quot;&gt;&lt;/a&gt;SQL语句集合&lt;/h3&gt;&lt;p&gt;这篇是用来记录我之前忘记的好多SQL语句的，因为有些SQL语句真的是不常用就会忘记的，记到这边来下次写SQL的时候可以看。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SQL" scheme="https://junshang11.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令相关</title>
    <link href="https://junshang11.com/2019/03/10/Linux%E8%AF%AD%E5%8F%A5%E7%9B%B8%E5%85%B3/"/>
    <id>https://junshang11.com/2019/03/10/Linux语句相关/</id>
    <published>2019-03-09T16:00:00.000Z</published>
    <updated>2019-09-17T09:33:18.972Z</updated>
    
    <content type="html"><![CDATA[<p>因为我一直用的是Mac OS，这是一个类Unix的系统，然后之前大一大二写Python的时候，有一本<learn python the hard way>里面，单独分了一章出来讲命令行语句，所以基础cd，mkdir，touch我也知道，写这个是因为我看到明天有个校招的公司要求有Linux基础，我这边抱个佛脚，记录一些使用频率高点的其他的命令。</learn></p><a id="more"></a><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><p>直接上来就是帮助，有时候假如我一个命令忘记了就直接用man + 命令去查看，比如我man ps，就能看到process status的详细信息。</p><p>但如果只想看简洁版的，就用–help。</p><h3 id="Vim相关"><a href="#Vim相关" class="headerlink" title="Vim相关"></a>Vim相关</h3><p>之前学的时候我是挺讨厌vim的，可能我没到那个级别，用vim修改python路径或者java路径的时候，总是不会用，后来用的多了感觉也还行。</p><p>vim分三个模式：</p><p><em>一般指令模式</em> ：默认模式，可以查看内容</p><p><em>编辑模式</em> ：按i进入，退出按esc</p><p>_指令列模式_： 按下：进入，保存，退出等操作。</p><p>一般的指令模式有:</p><pre>:w 写磁盘；:w! 强制写磁盘:q 退出:q! 强制退出不保存:wq 写入磁盘后离开:wq! 强制写入磁盘后离开</pre><h3 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h3><p>ls,cd,mkdir,cp,rm这些我熟悉就不写了吧，写个我自己老是忘的:</p><p><code>touch [-acdmt] filename</code></p><pre>这里面的常用的参数含义是：-a:更新-c:文件不存在就创建新文件-m: 更新</pre><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p><code>chmod [-R] xyz dirname/filename</code></p><p>好像是计算机组成原理的时候学过，r:4,w:2,x:1</p><p>这边的xyz指的是三组人群，owner，同组用户，其他用户</p><p>也可以用符号来设定权限：</p><pre># chmod [ugoa][+-=] [rwx] dirname/filename- u：拥有者- g：所属群组- o：其他人- a：所有人- +：添加权限- -：移除权限- =：设定权限</pre><h3 id="获取文件内容"><a href="#获取文件内容" class="headerlink" title="获取文件内容"></a>获取文件内容</h3><pre>cat:取得文件内容tac：cat的反向操作，从最后一行开始打印more：可以一页一页地查看文件内容less：和more差不多，但有个向前翻页的功能</pre><h3 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h3><p>记一个常用的gzip吧</p><pre>gzip [-cdtv#] filename-c ：将压缩的数据输出到屏幕上-d ：解压缩-t ：检验压缩文件是否出错-v ：显示压缩比等信息-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6</pre><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>这块应该是我看到的最多的面试题目。</p><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>全称是process status ，查看某个时间点的进程信息的</p><p>ps -I  :查看自己的进程</p><p>ps aux 查看系统所有进程</p><p>ps aux | grep threadx 查看特定进程</p><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>实时显示进程信息</p><p>top -d 2</p><h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><p>查看所有进程树</p><p>Pstree -A</p><p>讲真。。主要一般开发都在unix这边，这个不练是真的记不住。我去装个虚拟机跑centos吧。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为我一直用的是Mac OS，这是一个类Unix的系统，然后之前大一大二写Python的时候，有一本&lt;learn python the hard way&gt;里面，单独分了一章出来讲命令行语句，所以基础cd，mkdir，touch我也知道，写这个是因为我看到明天有个校招的公司要求有Linux基础，我这边抱个佛脚，记录一些使用频率高点的其他的命令。&lt;/learn&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://junshang11.com/tags/Linux/"/>
    
  </entry>
  
</feed>
