<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>君十一</title>
  
  <subtitle>Stay hungry Stay foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://junshang11.com/"/>
  <updated>2019-10-05T01:57:47.899Z</updated>
  <id>https://junshang11.com/</id>
  
  <author>
    <name>Jun Shang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot+Redis的应用</title>
    <link href="https://junshang11.com/2019/10/03/SpringBoot+redis/"/>
    <id>https://junshang11.com/2019/10/03/SpringBoot+redis/</id>
    <published>2019-10-02T16:00:00.000Z</published>
    <updated>2019-10-05T01:57:47.899Z</updated>
    
    <content type="html"><![CDATA[<p>今天要整的内容是SpringBoot和Redis的整合应用。这一篇的主要内容是：</p><ol><li><p>使用redisTemplate操作数据</p></li><li><p>用Redis Repository整体操作hash对象</p></li></ol><p>开始吧</p><a id="more"></a><h3 id="使用redisTemplate操作数据"><a href="#使用redisTemplate操作数据" class="headerlink" title="使用redisTemplate操作数据"></a>使用redisTemplate操作数据</h3><p>SpringBoot和Redis的整合还是挺容易的，因为他给我们封装了很棒的redisTemplate模版封装类，想要使用它，第一步，先命令行开启Redis服务端。第二步导包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>SpringBoot 2.0 默认使用的Redis客户端是lettuce，这边引入commons-pool2 是因为lettuce需要commons-pool 2 创建 Redis 连接池。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    database: 0 # Redis 数据库索引（默认为 0）</span><br><span class="line">    host: 127.0.0.1 # Redis 服务器地址</span><br><span class="line">    port: 6379 # Redis 服务器连接端口</span><br><span class="line">    password: ericshang11 # Redis 服务器连接密码（默认为空）</span><br><span class="line">    lettuce:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 8 # 连接池最大连接数（使用负值表示没有限制） 默认 8</span><br><span class="line">        max-wait: -1 # 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1</span><br><span class="line">        max-idle: 8 # 连接池中的最大空闲连接 默认 8</span><br><span class="line">        min-idle: 0 # 连接池中的最小空闲连接 默认 0</span><br></pre></td></tr></table></figure><p>这时候，我们就能拿到redisTemplate。其实spring-boot-starter-data-redis提供了两种模版封装类，这边我使用的是redisTemplate，因为它更加通用，而StringRedisTemplate只能操作list。redisTemplate操作各个数据结构的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redisTemplate.opsForValue();//操作字符串</span><br><span class="line">redisTemplate.opsForHash();//操作 hash</span><br><span class="line">redisTemplate.opsForList();//操作 list</span><br><span class="line">redisTemplate.opsForSet();//操作 set</span><br><span class="line">redisTemplate.opsForZSet();//操作有序 set</span><br></pre></td></tr></table></figure><p>那如何注入模版类呢，有两种方法。</p><p>一种直接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RedisTemplate&lt;String, String&gt; template;</span><br></pre></td></tr></table></figure><p>另一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Resource(name = &quot;redisTemplate&quot;)</span><br><span class="line">private ValueOperations&lt;String,Object&gt; valueOperations; //操作string</span><br><span class="line">private ListOperations&lt;String, String&gt; listOps; //只操作list</span><br><span class="line">private HashOperations&lt;String, String, Object&gt; hashOperations;//操作hash</span><br><span class="line">private SetOperations&lt;String, Object&gt; setOperations; //操作set</span><br><span class="line">private ZSetOperations&lt;String, Object&gt; zSetOperations; //操作set</span><br></pre></td></tr></table></figure><p>第二种是注入了RedisTemplate的子类。两种都可以。</p><p>我们这边用RedisTemplate去操作一个将一个String类型的元素放入redis中。</p><p>首先创建数据对象，一定要implements Serializable，因为将数据放入redis中，就是一个将对象序列化的过程，所以一定要实现Serializable。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Person implements Serializable &#123;</span><br><span class="line">  String firstname;</span><br><span class="line">  String lastname;</span><br></pre></td></tr></table></figure><p>然后创建一个testcontroller，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class testcontroller &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&quot;/string&quot;)</span><br><span class="line">   public Object testString()&#123;</span><br><span class="line">      Person person = new Person();</span><br><span class="line">      person.setFirstname(&quot;eric&quot;);</span><br><span class="line">      person.setLastname(&quot;shang&quot;);</span><br><span class="line">      redisTemplate.opsForValue().set(&quot;person:1&quot;, person);//放入键为person:1的String类型元素中</span><br><span class="line">      Person getback = (Person) redisTemplate.opsForValue().get(&quot;person:1&quot;);//拿出来</span><br><span class="line">      return getback;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这样，我们用postman测试一下，就可以看到数据成功显示了。</p><p>但这边有两个坑，一个是redis会出现乱码，原因是RedisTemplate默认使用的是JdkSerializationRedisSerializer，它是以二进制形式保存的，而且它比json格式大很多，这时候，我们就需要对他进行配置。将RedisTemplate的序列化方式做一点改变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;</span><br><span class="line">        RedisTemplate redisTemplate = new RedisTemplate();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line"></span><br><span class="line">        ObjectMapper objectMapper = new ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line"></span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">        //重点在这四行代码</span><br><span class="line">        redisTemplate.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以看到乱码消失了。但这边乱码消失了，在redis-cli里，我们看我们的key，value还是会出现乱码，这时候，我们需要这么进入客户端</p><p><code>redis-cli --raw</code></p><p>这样，中文之类的key和value就可以显示了。</p><p>关于RedisTemplate对于不同数据类型提供的方法，这边推荐一个人的博客，整理的很好。<a href="https://blog.csdn.net/weixin_37490221/article/details/78135815" target="_blank" rel="noopener">redisTemplate访问redis数据结构</a></p><h3 id="用Redis-Repository整体操作hash对象"><a href="#用Redis-Repository整体操作hash对象" class="headerlink" title="用Redis Repository整体操作hash对象"></a>用Redis Repository整体操作hash对象</h3><p>因为hash结构是唯一能存放对象的，所以我们在操作hash数据结构的时候，得一个一个添加，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void HashOperations() throws Exception&#123;</span><br><span class="line">       Person person = new Person(&quot;boke&quot;,&quot;byrant&quot;);</span><br><span class="line">       hashOperations.put(&quot;hash:player&quot;,&quot;firstname&quot;,person.getFirstname());</span><br><span class="line">       hashOperations.put(&quot;hash:player&quot;,&quot;lastname&quot;,person.getLastname());</span><br><span class="line">       hashOperations.put(&quot;hash:player&quot;,&quot;address&quot;,person.getAddress());</span><br><span class="line">       System.out.println(hashOperations.get(&quot;hash:player&quot;,&quot;firstname&quot;));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这样的添加方式在元素较多的情况下会显得格外麻烦，所以我们这边学着使用Redis Repository去整体地操作hash对象。</p><p>Repository是spring-data中对于数据库的增删改查的中央存储库。通过它可以对数据库（redis)进行操作。基本的实现为CrudRepository。 那redis通过支持repository，来实现对model在缓存中的增删改查。</p><p>首先我们必须开启支持repository，通过@EnableRedisRepositories，就可以开启redis对repository的支持，通常，我们将@EnableRedisRepositories放在项目入口处，或者将这个放在redis config文件上，这样项目就会自动开启对RedisRepositories的支持。</p><p>然后在数据对象上加上<br><code>@RedisHash("people")</code></p><p>在id属性上加伤@Id</p><p>这连个个的作用是啥呢，给这个对象生成hash数据类型中的key，那这样的话，之后再生成对象的话，redis repository会过来拿这个key。</p><p>之后我们再写一个接口实现CrudRepository</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface PersonRepository extends CrudRepository&lt;Person, String&gt; &#123;</span><br><span class="line"> // 继承CrudRepository，获取基本的CRUD操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放在dao包下。</p><p>之后我们就可以编写代码了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">    PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testHashRep()&#123;</span><br><span class="line">        Person rand = new Person(&quot;eric&quot;, &quot;shang&quot;);</span><br><span class="line">        personRepository.save(rand); //保存进redis</span><br><span class="line">        </span><br><span class="line">        Optional&lt;Person&gt; op = personRepository.findById(rand.getId());//通过key查找元素</span><br><span class="line">        Person p2 = op.get();</span><br><span class="line">      System.out.println(p2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们就可以在控制台看到，元素被读取出来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天要整的内容是SpringBoot和Redis的整合应用。这一篇的主要内容是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用redisTemplate操作数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用Redis Repository整体操作hash对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;开始吧&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Redis" scheme="https://junshang11.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>redis学习手册-青铜级</title>
    <link href="https://junshang11.com/2019/10/02/redis%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
    <id>https://junshang11.com/2019/10/02/redis学习手册/</id>
    <published>2019-10-01T16:00:00.000Z</published>
    <updated>2019-10-03T08:42:36.095Z</updated>
    
    <content type="html"><![CDATA[<p>到昨天为止学完了SpringBoot基础，今天开始学redis，然后完了之后写一个SpringBoot和Redis的整合。这篇的整体结构是</p><ol><li><p>基础的操作</p></li><li><p>基础的数据类型和使用场景</p></li></ol><p>那我们就开始吧。</p><a id="more"></a><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><h4 id="打开-关闭-连接之类的"><a href="#打开-关闭-连接之类的" class="headerlink" title="打开/关闭/连接之类的"></a>打开/关闭/连接之类的</h4><p>redis的有点什么特点的，这边就不赘述了，一搜就有好多，这边整点我容易忘记的操作。</p><p>我是Mac端整的，所以直接官网下包，放到根目录下，cd进目录，然后redis-server打开服务端。然后redis-cli 进入客户端操作。</p><p>这边有条命令可以查看redis服务是否开启的。</p><p><code>ps -ef | grep redis</code></p><p>如果看到有个6379的端口开着，那说明我们的服务是启动着的。</p><p>关于关闭redis，一般来说是在redis-cli里直接shutdown，这是断电保护，会把当前操作保存，还有一种暴力的，先通过</p><p><code>ps -ef | grep redis</code>找到redis的pid，然后直接kill - 9 pid，杀了它。</p><h4 id="redis-conf-相关"><a href="#redis-conf-相关" class="headerlink" title="redis.conf 相关"></a>redis.conf 相关</h4><p>redis.conf这个配置文件，它注释写得非常全，我这边主要注意的是三个操作和两个注意点。</p><ol><li><p>requirepass这边设置密码</p></li><li><p>daemonize 设置为yes，这样你退出了终端，你的redis依然在跑</p></li><li><p>把bind注释掉，这样子允许除本机外的客户端访问。</p><p>注释掉以后，要是远程的客户端访问，命令是<br><code>redis-cli -h host -p port -a password</code><br> 解释是这样的：redis-cli –h IP地址 –p 端口 –a 密码</p></li></ol><p>两个注意点:</p><ol><li><strong>save <seconds> <changes></changes></seconds></strong></li></ol><p>这条命令记录的是你的持久化策略，多长时间进行一次保存操作：</p><p>​    <strong>save 900 1</strong></p><p>​    <strong>save 300 10</strong></p><p>​    <strong>save 60 10000</strong></p><p>​    分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改，这边可以根据自己的需求做出修改。</p><ol start="2"><li>MAXMEMORY POLICY 这块</li></ol><p>这边记录的是，当你的缓存不能再放的情况下，你的缓存释放策略。<br>redis缓存的释放有两种方法，一种就是在你设定好了键值对以后，你用expire命令，却规定它什么时候过期。<br>还有一种操作就是这时候，你在conf里面制定你的缓存释放策略，redis的缓存淘汰策略是用LRU算法动态将不常用的数据删除。这边界定不常用的数据提供的选项是：</p><p>1.volatile-lru：设定超时时间的数据中,删除最不常使用的数据.</p><p>2.allkeys-lru：查询所有的key中最近最不常使用的数据进行删除，这是应用最广泛的策略.</p><p>3.volatile-random：在已经设定了超时的数据中随机删除.</p><p>4.allkeys-random：查询所有的key,之后随机删除.</p><p>5.volatile-ttl：查询全部设定超时时间的数据,之后排序,将马上将要过期的数据进行删除操作.</p><p>6.noeviction：如果设置为该属性,则不会进行删除操作,如果内存溢出则报错返回.<br>    volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键<br>    allkeys-lfu：从所有键中驱逐使用频率最少的键</p><p>redis的默认设置是6。可以根据自己项目的需求，自动配置。</p><p>在我们做出了相应的配置后，我们怎么才能去让我们的配置生效呢。<br><code>redis-server redis.conf</code></p><p>这样，redis启动服务端的时候，就会去读取redis.conf里我们的新配置。</p><p>以上是，redis的基础操作。接下来我们谈谈redis提供的数据结构，和我们的日常使用场景。</p><h3 id="数据类型和使用场景"><a href="#数据类型和使用场景" class="headerlink" title="数据类型和使用场景"></a>数据类型和使用场景</h3><h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>最基础的数据结构，常用的操作是</p><pre><code>set key stringget keydel key incr keyincrby key incrementappend key value</code></pre><p>String类型最常用的使用场景就是计数器，并且redis的所有命令都是原子性的，所以当出现竞态条件的时候，比如多个客户端都进行incr命令，并不会出现value重复加1的情况。</p><h4 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h4><p>hash类型最大的特点在于，他可以存储对象。</p><p>常用的操作是:</p><pre><code>hset key field value, field valuehget key fieldhmset key field value  key field valuehmget key field hgetall keyhkeys keyhvals key </code></pre><p>hash最多的使用场景就是存储存储部分变更数据，如用户信息等。</p><h4 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h4><p>list类型的实现方法是双向链表，这样的设计，让它的添加元素的时间复杂度是O(1)，获取越接近两端的元素，速度越快。</p><p>常用的操作是：</p><pre><code>lpush key value1 value2 rpush key value1 lpop key rpop keyllen key lrange key start stop linsert key before/after key1 value1lrem key count value    // 删除列表中前count个值为value的元素，也就是删除列表中指定的值</code></pre><p>list的使用场景是啥呢，</p><p><strong>对数据量大的集合数据删减</strong>：</p><p>列表数据显示、关注列表、粉丝列表、留言评价等…分页、热点新闻（Top5)等。</p><h4 id="Set类型-集合类型"><a href="#Set类型-集合类型" class="headerlink" title="Set类型 集合类型"></a>Set类型 集合类型</h4><p>set类型的内部实现是hashtable，所以加入，删除等操作的时间复杂度都是O(1)。</p><p>常用的操作是：</p><pre><code>sadd key member1 member2 srem key membersmembers keysismember key member//集合间的运算sdiff key1 key2  差集sinter key1 key2 交集sunion key1 key2 并集</code></pre><p>set最突出的特点就是，它多个集合类型键之间可以进行并行，交集，和差集运算。那这些运算有什么用呢，放在现实生活里面的例子就是，找到共同关注、共同喜好等功能。然后因为它内部实现是hashtable，所以它具有唯一性，所以它可以用作记录访问的独立ip，可以存储文章的唯一标签。</p><h4 id="ZSET类型-有序集合类型"><a href="#ZSET类型-有序集合类型" class="headerlink" title="ZSET类型  有序集合类型"></a>ZSET类型  有序集合类型</h4><p>它和集合类型最大的区别就在于，它是有序的。它是通过将每个元素关联一个分数，通过分数，就可以对元素进行排序。有序集合的实现是hashtable和skip list（fuck，又是一个我不熟的数据结构，回头补起来）。</p><p>常用的操作是：</p><pre><code>zadd key score1 member1 score2 member2 //分数支持双精度浮点数zscore key member zrange key start stop [withscores] 从小到大zrevrange key start stop [withscores] zrangebyscore key min max [withscores]//例子 -inf 负无穷 inf 正无穷 不包含(zrangebyscore score  (80 +inf       //高于80分的zincrby key increment member   //增加某个元素的分数zincrby score 4 tom   // tom加4分</code></pre><p>基于它的底层实现结构，zset经常被运用在排行榜的实现中。比如说，我这边写一个文章点击量的排序。</p><pre><code>zadd posts:views 1 post1 2 post2//当有人看了post1zincrby posts:views 2 post1//看一些新的排行zrevrangebyscore posts:views +inf -inf</code></pre><p>这样就可以看到post1在前，post2 在后了。</p><p>以上就是基础的数据类型的操作和使用场景。</p><h3 id="键的操作"><a href="#键的操作" class="headerlink" title="键的操作"></a>键的操作</h3><p>如何查看所有的键呢</p><p>keys *</p><p>如何看某个键是否存在呢</p><p>exists key</p><p>前面做测试，整了各种键，键的命名还是尽可能规范的好，像我上面的，posts:view， 就算的上是有意义的键，不规范的命名，可读性贼差，所以这边我们把之前所有的键全部删掉。</p><p>如何删除所有的键呢</p><p>flushall</p><p>还有之前在清楚内存策略里，我提过可以用expire设置键的存活时间，是这样的</p><p>expire key seconds，单位是秒。比如说expire key1 300。</p><p>想要查看key1的存活时间，可以用，ttl key来查看。</p><p>那我假如说想要移除key1的过期时间呢，就用persist key 1就可以了。</p><p>ok，以上就是redis的基础部分了，接下来我们就开始准备用Springboot 去整合redis了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到昨天为止学完了SpringBoot基础，今天开始学redis，然后完了之后写一个SpringBoot和Redis的整合。这篇的整体结构是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基础的操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基础的数据类型和使用场景&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那我们就开始吧。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Redis" scheme="https://junshang11.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>RESTful封装思想，Dozer使用</title>
    <link href="https://junshang11.com/2019/09/26/RESTful/"/>
    <id>https://junshang11.com/2019/09/26/RESTful/</id>
    <published>2019-09-25T16:00:00.000Z</published>
    <updated>2019-09-29T03:27:54.782Z</updated>
    
    <content type="html"><![CDATA[<p>Springboot第二天，又学到了很多很有意思的东西，这边来记录一下这三个比较amaze我的。</p><a id="more"></a><h3 id="先说RESTful学到的封装写法"><a href="#先说RESTful学到的封装写法" class="headerlink" title="先说RESTful学到的封装写法"></a>先说RESTful学到的封装写法</h3><p>RESTful风格概念我这边就不多写了，因为之前学ssm的时候自己就查过详细的资料，这边上个链接，忘了再来看看 <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解RESTful架构</a>。</p><p>然后当时ssm的写法是配置了一个HiddenHttpMethodFilter过滤器，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">   &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">   &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">HiddenHttpMethodFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">   &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">HiddenHttpMethodFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">   &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在form表单里面加上一个新的值，</p><p><code><input type="hidden" name="_method" value="DELETE"></code></p><p>这样在后台就知道你这个方法是个delete请求了。这是ssm里面的写法，挺有意思的是这个隐藏域的思想。然后现在SpringBoot就很简单了，直接用注解，@PutMapping，@GetMapping，这些就能直接匹配到Restful风格的请求。</p><p>以上是基础的，我这边着重想写的是啥呢，RESTful的返回值，不应该仅仅只有返回的数据，他还应该包括响应的状态码，结果描述信息，然后再是请求的结果。那这样的情况下，我们可以把这些封装起来，再搞个封装类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class AjaxResponse &#123;</span><br><span class="line"></span><br><span class="line">    private boolean isok;   //请求是否处理成功</span><br><span class="line">    private int code;          //请求响应状态码（200、400、500）</span><br><span class="line">    private String message;  //请求结果描述信息</span><br><span class="line">    private Object data;  //请求结果数据</span><br><span class="line"></span><br><span class="line">    private AjaxResponse() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static AjaxResponse success() &#123;</span><br><span class="line">        AjaxResponse resultBean = new AjaxResponse();</span><br><span class="line">        resultBean.setIsok(true);</span><br><span class="line">        resultBean.setCode(200);</span><br><span class="line">        resultBean.setMessage(&quot;success&quot;);</span><br><span class="line">        return resultBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static AjaxResponse success(Object data) &#123;</span><br><span class="line">        AjaxResponse resultBean = new AjaxResponse();</span><br><span class="line">        resultBean.setIsok(true);</span><br><span class="line">        resultBean.setCode(200);</span><br><span class="line">        resultBean.setMessage(&quot;success&quot;);</span><br><span class="line">        resultBean.setData(data);</span><br><span class="line">        return resultBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思想很有意思。其实这种思想不是第一次碰见吧，之前用pagehelper分页工具的时候，也是这个思想，把信息和分页需要的相关数据封装起来，然后向前端返回一个pageinfo的对象，再在前端解析它。</p><p>这边写这个其实意义在于，想告诉自己思路要灵活，不要死板，要熟悉各种编程思想。</p><h3 id="Dozer的使用"><a href="#Dozer的使用" class="headerlink" title="Dozer的使用"></a>Dozer的使用</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在此之前，我是没想过一个项目需要两个pojo类的。但是在接触了Dozer以后，你是能感觉到它存在的必要性的。因为你传到表现层的数据visual object (vo) ，多多少少应该和你查询出来的数据有所出入。</p><p>比如说你想用jackson去对返回的数据做个处理，比如说我id值不返回给前端，我用@JsonIgnore 排除id，那这样的标示放在po上是不合理的。所以这时候，我们就要区分po和vo。</p><h4 id="dozer是什么以及使用"><a href="#dozer是什么以及使用" class="headerlink" title="dozer是什么以及使用"></a>dozer是什么以及使用</h4><p>所以我们这边介绍dozer，它是一个能把实体和实体之间进行转换的工具，只要建立好映射关系，就像是ORM的数据库和实体映射一样。写法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EntityVo entityVo = dozerMapper.map(entity, EntityVo.class);</span><br></pre></td></tr></table></figure><p>接下来讲一下这玩意怎么配置到项目中的，首先老规矩添加依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;net.sf.dozer&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;dozer&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;5.4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后创建一个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DozerBeanMapperConfigure</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Bean</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> DozerBeanMapper <span class="title">mapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           DozerBeanMapper mapper = <span class="keyword">new</span> DozerBeanMapper();</span><br><span class="line">           <span class="keyword">return</span> mapper;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以直接使用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">protected Mapper dozerMapper;</span><br></pre></td></tr></table></figure><p>具体的场景举个例子：比如说我们想要查询编号为1的员工信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Employeevo getEmployee(int id)&#123;</span><br><span class="line">  //查询到了信息，这是一个po</span><br><span class="line">Employee employee = EmployeeMapper.selectByPrimaryId(id);</span><br><span class="line">//将它转为vo</span><br><span class="line">Employeevo employeevo = dozerMapper.map(employee,Employeevo.class);</span><br><span class="line">return employeevo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那有时候我们返回的是多个对象呢，那我们就需要借助工具类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DozerUtils &#123;</span><br><span class="line"></span><br><span class="line">    static DozerBeanMapper dozerBeanMapper = new DozerBeanMapper();</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; List&lt;T&gt; mapList(Collection sourceList, Class&lt;T&gt; destinationClass)&#123;</span><br><span class="line">        List destinationList = Lists.newArrayList();</span><br><span class="line">        for (Iterator i$ = sourceList.iterator(); i$.hasNext();)&#123;</span><br><span class="line">            Object sourceObject = i$.next();</span><br><span class="line">            Object destinationObject = dozerBeanMapper.map(sourceObject, destinationClass);</span><br><span class="line">            destinationList.add(destinationObject);</span><br><span class="line">        &#125;</span><br><span class="line">        return destinationList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来个例子，比如说我们要查询所有的员工信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Employeevo&gt; getAll()&#123;</span><br><span class="line">  //查询到了信息，这是一个po</span><br><span class="line">List&lt;Employee&gt; employees = EmployeeMapper.selectByExample(null);</span><br><span class="line">//调用工具类中的mapList方法</span><br><span class="line">List&lt;Employeevo&gt; employeevos = dozerMapper.mapList(employees,Employeevo.class);</span><br><span class="line">return employeevos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样子的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Springboot第二天，又学到了很多很有意思的东西，这边来记录一下这三个比较amaze我的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="https://junshang11.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Git小结</title>
    <link href="https://junshang11.com/2019/09/26/git%E5%B0%8F%E7%BB%93/"/>
    <id>https://junshang11.com/2019/09/26/git小结/</id>
    <published>2019-09-25T16:00:00.000Z</published>
    <updated>2019-09-26T13:45:20.008Z</updated>
    
    <content type="html"><![CDATA[<p>最近超卖力地学SpringBoot，然后写很多demo。之前git不太熟，只知道add，commit，checkout这些，现在懂了更多，所以写一篇记录一下这些操作。</p><a id="more"></a><p>不讲那些我已经懂的，svn和git区别，什么本地仓库，工作区概念之类的了，直接开冲常用命令好吧。</p><h4 id="git-int"><a href="#git-int" class="headerlink" title="git int"></a>git int</h4><p>创建一个空的本地仓库</p><h4 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h4><p>这是将修改添加到暂存区<br>有几个后缀的</p><p>git add -A 是全部添加</p><p>git add -u 将当前目录下所有跟踪文件中被修改过或已删除文件的信息添加到索引库</p><p>通常情况下，直接是-A</p><h4 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h4><p>检查文件状态<br>在commit之前，用git status检查一下文件状态是个很好的习惯</p><h4 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h4><p>将更改记录(提交)到存储库<br>通常情况下写的是git commit -m’annotation’<br>加了注释的话，在log里能更直观</p><h4 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h4><p>对分支的操作<br>比如说我创建一个新的分支<br>git branch dev<br>那我就得到了一个dev的分支</p><h4 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h4><p>切换分支也可以取出误删的文件<br>比如说我<br>rm -f hello.py<br>那我就可以用<br>git checkout hello.py 把它找回来</p><h4 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h4><p>这个命令可以把两个或两个以上的开发历史加入(合并)一起<br>比如说我想把dev 这个分支 合并到master下<br>就是git checkout master 到主分支下<br>然后 git merge dev</p><h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><p>将本地的版本，推送到远程主机<br>git push origin master</p><h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>取回远程主机某个分支的更新，再与本地的指定分支合并<br>它相当于先做了git fetch，然后再git merge</p><p>这些是我碰到的常用，接下来提一下cherry pick</p><h4 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry pick"></a>git cherry pick</h4><p>就比如说，我想要dev分支的某笔提交的内容，并入我目前的分支上，我不需要全部的内容，那这时候就可以用git cherry pick。那完整的流程就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git log //查看几次提交的内容</span><br><span class="line">git checkout master //回到当前的分支</span><br><span class="line">git cherry pick 20fe2f9 //将dev的20fe2f9这个分支给拿过来</span><br></pre></td></tr></table></figure><p>就是这些啦，我之前觉得git烦，现在的感觉就是，git真香啊。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近超卖力地学SpringBoot，然后写很多demo。之前git不太熟，只知道add，commit，checkout这些，现在懂了更多，所以写一篇记录一下这些操作。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Git" scheme="https://junshang11.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>lombok</title>
    <link href="https://junshang11.com/2019/09/25/lombok/"/>
    <id>https://junshang11.com/2019/09/25/lombok/</id>
    <published>2019-09-24T16:00:00.000Z</published>
    <updated>2019-09-29T03:28:00.456Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学Springboot，看教程看到了一个挺实用的工具，lombok，这边记录一下它的使用方法，和几个常用注解的含义。</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先是配置依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.16.18&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后去idea的插件库里去寻找Lombok plugin，安装重启就行了。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="Lombok作用"><a href="#Lombok作用" class="headerlink" title="Lombok作用"></a>Lombok作用</h4><p>Lombok最关键的作用是能够自动帮我们生成get/set，constructor等等。虽然这些idea能帮我们自动生成，但是只用注解就能默认生成的方式，能在阅读代码的时候更加focus在类的属性。就比如我这个bean 10几个属性，那我改了一个属性的名称，现在下面constructor，get/set方法全都要改，那不是很烦么。所以Lombok的出现，让可读性好了很多。</p><p>接下来，说明一些常用注解的方法。</p><h4 id="常用注解说明"><a href="#常用注解说明" class="headerlink" title="常用注解说明"></a>常用注解说明</h4><h6 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h6><p>提供类所有属性的 get 和 set 方法，此外还提供了equals、canEqual、hashCode、toString 方法。</p><h5 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a>@AllArgsConstructor</h5><p>为类提供一个全参的构造方法，加了这个注解后，类中不提供默认构造方法了</p><h5 id="NoArgsConstructor"><a href="#NoArgsConstructor" class="headerlink" title="@NoArgsConstructor"></a>@NoArgsConstructor</h5><p>为类提供一个无参的构造方法。</p><h5 id="NonNull"><a href="#NonNull" class="headerlink" title="@NonNull"></a>@NonNull</h5><p>注解在 属性 上，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，也会有一个默认的无参构造方法。</p><h5 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h5><p>这个是最棒的，这边写个例子。<br>比如说我一个pojo的属性是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在加上了@Builder注解后，我们在创建对象的时候，可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UserExample userExample = UserExample.builder()</span><br><span class="line">                .id(1)</span><br><span class="line">                .name(&quot;aaa&quot;)</span><br><span class="line">                .address(&quot;bbb&quot;)</span><br><span class="line">                .build();</span><br><span class="line">System.out.println(userExample);</span><br></pre></td></tr></table></figure><p>这样就可以创建出一个对象了。</p><p><strong>这边有个坑</strong></p><p>关于子类使用@Builder后，拿不到父类属性的办法。虽然我没有遇到过，但我查Lombok的使用时，很多人都反映过这个情况。这边记录一下解决办法。</p><p>首先父类需要一个全参构造方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@AllArgsConstructor</span><br><span class="line">public class Parent &#123;</span><br><span class="line">  private String a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类这边，手写一个全参构造方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Child extends Parent &#123;</span><br><span class="line">  private String b;</span><br><span class="line"></span><br><span class="line">  @Builder</span><br><span class="line">  private Child(String a, String b)&#123;</span><br><span class="line">    super(a);</span><br><span class="line">    this.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，你在创建子类的时候，就不会找不到父类的属性了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.builder().a(&quot;testA&quot;).b(&quot;testB&quot;).build();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学Springboot，看教程看到了一个挺实用的工具，lombok，这边记录一下它的使用方法，和几个常用注解的含义。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SpringBoot" scheme="https://junshang11.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>多线程初探</title>
    <link href="https://junshang11.com/2019/09/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E6%8E%A2/"/>
    <id>https://junshang11.com/2019/09/24/多线程初探/</id>
    <published>2019-09-23T16:00:00.000Z</published>
    <updated>2019-09-26T09:35:21.570Z</updated>
    
    <content type="html"><![CDATA[<p>我多线程之前3月份准备面试的时候，看过完整的马士兵老师的课，做了手抄笔记，那时候面试的时候还能答得上来，后来去了凌志，写写sql，没怎么碰都忘得差不多了，所以这篇来重新整理一下多线程相关的知识。</p><a id="more"></a><h3 id="线程的基础"><a href="#线程的基础" class="headerlink" title="线程的基础"></a>线程的基础</h3><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>首先问题就是，什么是线程什么是进程，用自己的理解的话，qq音乐app打开，这整体就是一个进程，然后打开以后检测用户登陆，开始匹配今日的最新推荐歌单，调整广告，这些都是线程。所以可以理解成是多个线程组成了一个进程，线程是最小的执行单位。</p><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><p>并发是同一时间段，多个任务都在进行。</p><p>并行是，单位时间内，多个任务同时执行。</p><p>这里面用的主要区别就是<strong>同时</strong>。</p><p>比如说双十一的前一天晚上22点10分，有些稀稀拉拉的购物狂在看不同商店里的打折商品，这是并发。并行是啥呢，双十一零点零分的时候，所有的人都在疯狂下单，这就是并行了。</p><h4 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h4><p><strong>New</strong>: 初始状态，创建了而未启动的方法</p><p><strong>Runnable</strong>： 包括两个子状态：ready和running状态，ready表示可以被调用了，running是正在运行。</p><p><strong>Blocked</strong>：一个线程发起了一个阻塞式I/O操作后，或者申请到了一个由其他线程持有的独占资源时，线程就会进入这个状态，也就是说想申请资源，结果被堵了。等拿到了资源，就又可以转为runnable了。</p><p><strong>Waiting</strong>：等待状态，线程不急着办事情，给人让路</p><p><strong>Timed_Waiting</strong>：也是等待，和waiting的区别在于，他是有时间限制的等待，时间限制后，直接进入runnable状态</p><p><strong>Terminated</strong>：结束了，线程使命完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我多线程之前3月份准备面试的时候，看过完整的马士兵老师的课，做了手抄笔记，那时候面试的时候还能答得上来，后来去了凌志，写写sql，没怎么碰都忘得差不多了，所以这篇来重新整理一下多线程相关的知识。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="多线程" scheme="https://junshang11.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>websocket的实现</title>
    <link href="https://junshang11.com/2019/09/22/websocket%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://junshang11.com/2019/09/22/websocket的实现/</id>
    <published>2019-09-21T16:00:00.000Z</published>
    <updated>2019-09-23T09:01:09.561Z</updated>
    
    <content type="html"><![CDATA[<p>周六家里有事，中午和我妈在饭店吃饭，看到一个挺有趣的点餐机制。扫码点餐，但是我在我这个界面点餐，我妈的手机立马就会更新最新的我点的东西。很好奇这么快的响应速度是怎么做到的，查了一些资料，得出的结论是用websocket实现的，然后周末就来写写看这个东西的原理是啥，是怎么实现的。</p><a id="more"></a><h3 id="websocket是什么"><a href="#websocket是什么" class="headerlink" title="websocket是什么"></a>websocket是什么</h3><pre>WebSocket 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯，它建立在 TCP 之上，同 HTTP 一样通过 TCP 来传输数据。</pre><p>传统的http请求客户端模式是什么呢，这边用IBM开发者社区的图来表示：</p><p><img src="/images/websocket/1.png" alt="传统http请求客户端模式"></p><p>而websocket的模式是：</p><p><img src="/images/websocket/2.png" alt="websocket模式"></p><p>可以看到websocket是类似 Socket 的 TCP 长连接的通讯模式，一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。这样的模式可见的优点是他很快，在断开连接之前，不需要重复发出请求，这样的模式能极大地节省网络带宽资源的消耗，以及它具有实时性，因此它能够实现我遇到的那种点单模式。</p><h3 id="实现一个简单的websocket"><a href="#实现一个简单的websocket" class="headerlink" title="实现一个简单的websocket"></a>实现一个简单的websocket</h3><p>WebSocket 的实现分为客户端和服务端两部分，客户端（通常为浏览器）发出 WebSocket 连接请求，服务端响应，实现类似 TCP 握手的动作，从而在浏览器客户端和 WebSocket 服务端之间形成一条 HTTP 长连接快速通道。两者之间后续进行直接的数据互相传送，不再需要发起连接和相应。</p><p>先看服务端，首先导入依赖，</p><pre></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.0&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在这个包中就有我们所需要的javax.websocket.*的 API。</p><p>然后开始写测试类，websocket的流程在于，使用@ServerEndpoint(     ) 作为服务器端的注解，注解的值被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端。</p><p>然后我们需要用concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。然后我们需要创建一个session对象，来存储对话。完整的服务器端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ServerEndpoint</span> 注解是一个类层次的注解，它的功能主要是将目前的类定义成一个websocket服务器端,</span></span><br><span class="line"><span class="comment"> * 注解的值将被用于监听用户连接的终端访问URL地址,客户端可以通过这个URL来连接到WebSocket服务器端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/websocket"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> onlineCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。若要实现服务端与单一客户端通信的话，可以使用Map来存放，其中Key可以为用户标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketTest&gt; webSocketSet = <span class="keyword">new</span> CopyOnWriteArraySet&lt;WebSocketTest&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接建立成功调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session  可选的参数。session为与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        webSocketSet.add(<span class="keyword">this</span>);     <span class="comment">//加入set中</span></span><br><span class="line">        addOnlineCount();           <span class="comment">//在线数加1</span></span><br><span class="line">        System.out.println(<span class="string">"有新连接加入！当前在线人数为"</span> + getOnlineCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        webSocketSet.remove(<span class="keyword">this</span>);  <span class="comment">//从set中删除</span></span><br><span class="line">        subOnlineCount();           <span class="comment">//在线数减1</span></span><br><span class="line">        System.out.println(<span class="string">"有一连接关闭！当前在线人数为"</span> + getOnlineCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 可选的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"来自客户端的消息:"</span> + message);</span><br><span class="line">        <span class="comment">//群发消息</span></span><br><span class="line">        <span class="keyword">for</span>(WebSocketTest item: webSocketSet)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                item.sendMessage(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生错误时调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable error)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发生错误"</span>);</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法与上面几个方法不一样。没有用注解，是根据自己需要添加的方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">        <span class="comment">//this.session.getAsyncRemote().sendText(message);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onlineCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketTest.onlineCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketTest.onlineCount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端代码如上，接下来我们编写客户端代码，通常客户端就是浏览器端，而如今绝大多数浏览器都已经支持websocket，所以我们直接写js代码。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> pageEncoding=<span class="string">"UTF-8"</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Java后端WebSocket的Tomcat实现&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">Welcome&lt;br/&gt;&lt;input id=<span class="string">"text"</span> type=<span class="string">"text"</span>/&gt;</span><br><span class="line">&lt;button onclick="send()"&gt;发送消息&lt;/button&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;button onclick="closeWebSocket()"&gt;关闭WebSocket连接&lt;/button&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;div id="message"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> websocket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//判断当前浏览器是否支持WebSocket</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'WebSocket'</span> in window) &#123;</span><br><span class="line">        websocket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:8080/websocket"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'当前浏览器 Not support websocket'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接发生错误的回调方法</span></span><br><span class="line">    websocket.onerror = function () &#123;</span><br><span class="line">        setMessageInnerHTML(<span class="string">"WebSocket连接发生错误"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接成功建立的回调方法</span></span><br><span class="line">    websocket.onopen = function () &#123;</span><br><span class="line">        setMessageInnerHTML(<span class="string">"WebSocket连接成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收到消息的回调方法</span></span><br><span class="line">    websocket.onmessage = function (event) &#123;</span><br><span class="line">        setMessageInnerHTML(event.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接关闭的回调方法</span></span><br><span class="line">    websocket.onclose = function () &#123;</span><br><span class="line">        setMessageInnerHTML(<span class="string">"WebSocket连接关闭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。</span></span><br><span class="line">    window.onbeforeunload = function () &#123;</span><br><span class="line">        closeWebSocket();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将消息显示在网页上</span></span><br><span class="line">    <span class="function">function <span class="title">setMessageInnerHTML</span><span class="params">(innerHTML)</span> </span>&#123;</span><br><span class="line">        document.getElementById(<span class="string">'message'</span>).innerHTML += innerHTML + <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭WebSocket连接</span></span><br><span class="line">    <span class="function">function <span class="title">closeWebSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        websocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="function">function <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> message = document.getElementById(<span class="string">'text'</span>).value;</span><br><span class="line">        websocket.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这样，当两个不同的客户端，对ws://localhost:8080/websocket，发出请求时，这样他们就进入了同一个session中，这样他们就能进行相互的对话了。</p><p>效果如图所示：</p><p>A点了红烧狮子头，这时B的客户端就能直接看到A点了狮子头</p><p><img src="/images/websocket/3.png" alt="效果图"></p><p>在B点了水煮肉片时，A的界面也能立刻出现水煮肉片的选项。</p><p><img src="/images/websocket/3.png" alt="效果图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周六家里有事，中午和我妈在饭店吃饭，看到一个挺有趣的点餐机制。扫码点餐，但是我在我这个界面点餐，我妈的手机立马就会更新最新的我点的东西。很好奇这么快的响应速度是怎么做到的，查了一些资料，得出的结论是用websocket实现的，然后周末就来写写看这个东西的原理是啥，是怎么实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="websocket" scheme="https://junshang11.com/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>Java经典面试题总结</title>
    <link href="https://junshang11.com/2019/09/19/Java%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://junshang11.com/2019/09/19/Java经典面试题/</id>
    <published>2019-09-18T16:00:00.000Z</published>
    <updated>2019-09-23T02:27:03.700Z</updated>
    
    <content type="html"><![CDATA[<p>这篇记一些我比较容易搞混的概念还有题目，尽量用自己的语言去表达出来，因为只有自己语言表达出来才是真的理解了吧。</p><a id="more"></a><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try catch finally"></a>try catch finally</h3><p>之前看过一个题目讲，如果try和finally里都有return，那么它的执行顺序是什么？</p><pre><code>try{ return; }    catch(){}     finally{}     return;</code></pre><p>他会先执行try块中return之前的语句，再到finally块，然后去try中的return。</p><p>然后还有种情况：</p><pre><code>try{ return; }    catch(){}     finally{return}     </code></pre><p>他会先执行try块中return之前的语句，再到finally这边，因为finally中有return，所以他会return后提前跳出。</p><p>所以结论是：<br>finally里的语句一定会执行，所以不建议在finally语句里加入return，因为会提前跳出，返回值不是try或者catch块里的返回值。</p><h3 id="equals-的那些事"><a href="#equals-的那些事" class="headerlink" title="equals, ==的那些事"></a>equals, ==的那些事</h3><p>== 一直是比较两个对象的地址是不是相等的，即两个对象是不是同一个对象。基本类型是比较值是否相同，引用类型是地址是否相同。</p><p>equals ，类如果没有覆盖equals方法，则通过equsls比较两个对象时，等价于通过”==”比较这两个对象，如果覆盖了，比如说string里的equals，那就是比较两个对象的值。</p><p>这里还有一个题目，</p><h4 id="为啥重写equals必须重写hashcode-方法？"><a href="#为啥重写equals必须重写hashcode-方法？" class="headerlink" title="为啥重写equals必须重写hashcode()方法？"></a>为啥重写equals必须重写hashcode()方法？</h4><p>任何类都具有自己的hashcode。</p><pre>如果两个对象相等，那么他们的hashcode一定是相同的；如果两个对象相等，那么两个对象调用equals方法都返回true；如果两个对象hashcode相同，那么两个对象可能equals不同（概率性问题）因此我们可以得出结论，如果说两个对象equals，那么他们的hashcode方法一定是相同的，所以如果equals重写了，hashcode()方法必定重写。</pre><p>这一篇记得是Java基础的问题，下一篇写多线程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇记一些我比较容易搞混的概念还有题目，尽量用自己的语言去表达出来，因为只有自己语言表达出来才是真的理解了吧。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试" scheme="https://junshang11.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>svn知识补全</title>
    <link href="https://junshang11.com/2019/09/10/svn/"/>
    <id>https://junshang11.com/2019/09/10/svn/</id>
    <published>2019-09-09T16:00:00.000Z</published>
    <updated>2019-09-29T03:28:04.193Z</updated>
    
    <content type="html"><![CDATA[<p>因为看到南通很多公司都用svn作为代码版本控制系统，而我之前用得多的是git吧。所以这篇学一下svn的基本操作，这样子面试遇到了也是有点准备的那种。</p><a id="more"></a><p>整体来说，svn和git还是有点像的。</p><h3 id="svn的生命周期"><a href="#svn的生命周期" class="headerlink" title="svn的生命周期"></a>svn的生命周期</h3><pre>创建版本库，检出checkout，更新update，执行变更 对文件内容的修改，复查变化status，重置修改revert，解决冲突merge，提交更改 commit</pre><p>因为Mac有自带的svn，直接terminal里输入svn help可以看到我的版本是1.10.3</p><ol><li><p>将文件checkout到本地</p><p>svn checkout path (path是服务器上的目录)</p><p>checkout这步就有点像git里的git add，将服务器的内容拉到本地做一个个人的工作空间</p></li></ol><ol start="2"><li><p>往版本库中添加新的文件</p><p>svn add file</p><p>比如说我svn add test.java</p></li></ol><ol start="3"><li><p>将改动的文件提交到版本库</p><p>svn commit -m “LogMessage“ [-N] [<em>–no-unlock] PATH</em></p></li></ol><ol start="4"><li><p>比较差异</p><p>svn diff path（将修改的文件与基础版本比较）</p></li></ol><ol start="5"><li>将两个版本之前的差异合并到当前文件<br>svn merge -r m:n path</li></ol><ol start="6"><li>查看文件或者目录状态<br>svn status path(目录下的文件和子目录的状态，正常状态不显示)<br>其中可能出现的参数：M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定</li></ol><ol start="7"><li>删除文件<br>svn delete path -m “delete test fle“</li></ol><ol start="8"><li><p>版本回退</p><p>svn revert file</p></li></ol><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为看到南通很多公司都用svn作为代码版本控制系统，而我之前用得多的是git吧。所以这篇学一下svn的基本操作，这样子面试遇到了也是有点准备的那种。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://junshang11.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化</title>
    <link href="https://junshang11.com/2019/09/01/SQL%E4%BC%98%E5%8C%96/"/>
    <id>https://junshang11.com/2019/09/01/SQL优化/</id>
    <published>2019-08-31T16:00:00.000Z</published>
    <updated>2019-09-17T08:21:25.506Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在最前面的"><a href="#写在最前面的" class="headerlink" title="写在最前面的"></a>写在最前面的</h3><p>说实话，真的没想到凌志是能这么玩的，强制转cobol，不然就进不了岗。我挺懵逼的，明明招进来的时候很明确地说了写java的啊。歇了两天，很认真地思考了一下以后的职业发展方向，还是不能接受转语言，周五选择离职应该是正确的决定。</p><p>我现在在想我过去的这两个月，自己所做的事情，有没有浪费时间。想了想，其实感觉也还好，最近真的看了很多数据库相关的东西，虽然没有涉及到那些高阶的，比如说分库分表之类的，但SQL整体的知识，索引的原理，一些sql优化的方向，这些知识是自己学到手了的。这边记录一下我笔记本上记录过的一些SQL优化的方法。</p><a id="more"></a><h3 id="一些基础的优化"><a href="#一些基础的优化" class="headerlink" title="一些基础的优化"></a>一些基础的优化</h3><h4 id="lt-gt-优化"><a href="#lt-gt-优化" class="headerlink" title="&lt;&gt;优化"></a>&lt;&gt;优化</h4><p>不等号通常不能走索引，通常情况下用union连接起来。比如说我这边检索出所有金额不等于100的订单，优化的语句就是</p><pre><code>select id from orders where amount >100）union all(select id from orders where amount <100 and amount>0);</100></code></pre><h4 id="OR优化"><a href="#OR优化" class="headerlink" title="OR优化"></a>OR优化</h4><p>or是无法使用联合索引的，比如说我要选出电话号码等于1111或者用户编号是11的用户姓名，就该用union来连接起来。</p><pre><code>(select username from users where mobile = '1111'union(select username from users where id = 11);</code></pre><pre>这边记录一下,union和union all的区别，union是会压缩重复的值，union all并不会</pre><h4 id="in-优化"><a href="#in-优化" class="headerlink" title="in 优化"></a>in 优化</h4><p>之前我记过，in适合主表大，字表小的情况，exist适合主表小子表大的情况，但不管怎么说都是子查询，这种偏嵌套的运行效率都不怎么高，应该尽量用left join来表示,我们这边举个例子是，找出身份是vip的人的用户的单号，涉及到两张表，user表和order表，我们来用left join写一下。</p><pre><code>select o.id from orders o left join user uon o.user_id = u.id where u.class = 'VIP';</code></pre><h4 id="几个不要"><a href="#几个不要" class="headerlink" title="几个不要"></a>几个不要</h4><ol><li>我前面索引那篇写过，不要对索引的数据进行任何计算，不然都会让索引失效。</li><li>不要用select *，这样子一定会走全表扫描，好好写表中的列</li><li>join虽然好，但不要连接超过三个以上的表。</li></ol><h4 id="如何发现需要优化的语句"><a href="#如何发现需要优化的语句" class="headerlink" title="如何发现需要优化的语句"></a>如何发现需要优化的语句</h4><h5 id="打开慢查询日志"><a href="#打开慢查询日志" class="headerlink" title="打开慢查询日志"></a>打开慢查询日志</h5><p>首先打开慢查询日志<br><code>set global slow_query_log='ON';</code><br>再次查看是否开启<br><code>show variables like'%slow_query_log';</code><br>设置时间的阀值<br><code>set global long_query_time = 3;</code></p><p>这样我们就设置好了阀值是3秒钟。</p><p>接下来要是查询语句超过了3秒，MySQL会自动地记录到慢查询日志中。我在我的mac上遇到的问题是，我找不到这个慢查询日志的地址，查了文档，我们可以使用</p><p><code>SELECT @@slow_query_log_file;</code></p><p>找到他。</p><h5 id="用Explain查看执行计划"><a href="#用Explain查看执行计划" class="headerlink" title="用Explain查看执行计划"></a>用Explain查看执行计划</h5><p>用这个对查询是否命中索引非常有用。</p><p>用我这边有的一个范例库nba举个例子</p><p><code>select player_name,  team_name from player  left join team  on player.team_id = team.team_id;</code></p><p>用explain看一下，这个的结果是：</p><p><img src="/images/SQL%E4%BC%98%E5%8C%96/1.png" alt="Explain"></p><p>在这么多参数中，我们主要关注的是type列，type列的几种情况是：</p><p><img src="/images/SQL%E4%BC%98%E5%8C%96/2.png" alt="Explain"></p><p>效率从低到高依次为 all &lt; index &lt; range &lt; index_merge &lt; ref &lt; eq_ref &lt; const/system，我们希望执行计划至少可以使用到range级别，如果看到了all和index，就需要去从SQL语句和索引设计的角度上进行改进。</p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在最前面的&quot;&gt;&lt;a href=&quot;#写在最前面的&quot; class=&quot;headerlink&quot; title=&quot;写在最前面的&quot;&gt;&lt;/a&gt;写在最前面的&lt;/h3&gt;&lt;p&gt;说实话，真的没想到凌志是能这么玩的，强制转cobol，不然就进不了岗。我挺懵逼的，明明招进来的时候很明确地说了写java的啊。歇了两天，很认真地思考了一下以后的职业发展方向，还是不能接受转语言，周五选择离职应该是正确的决定。&lt;/p&gt;
&lt;p&gt;我现在在想我过去的这两个月，自己所做的事情，有没有浪费时间。想了想，其实感觉也还好，最近真的看了很多数据库相关的东西，虽然没有涉及到那些高阶的，比如说分库分表之类的，但SQL整体的知识，索引的原理，一些sql优化的方向，这些知识是自己学到手了的。这边记录一下我笔记本上记录过的一些SQL优化的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MySQL" scheme="https://junshang11.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL经典实例1</title>
    <link href="https://junshang11.com/2019/08/24/SQL%E7%BB%8F%E5%85%B8%E5%AE%9E%E4%BE%8B1/"/>
    <id>https://junshang11.com/2019/08/24/SQL经典实例1/</id>
    <published>2019-08-23T16:00:00.000Z</published>
    <updated>2019-09-15T07:34:52.786Z</updated>
    
    <content type="html"><![CDATA[<p>这是我最近找到的一本很棒的关于SQL的书，里面记录了150多个SQL常见问题和解决方法，最近做了挺久的sql优化，感觉自己还是蛮熟练的了，结果看到这本是真的被amaze了一下。复杂场景下，sql得会写才有机会优化吧，这本书追了追了。</p> <a id="more"></a><h3 id="1-SQL中使用条件逻辑"><a href="#1-SQL中使用条件逻辑" class="headerlink" title="1.SQL中使用条件逻辑"></a>1.SQL中使用条件逻辑</h3><p>case函数的使用</p><pre><code>Select ename,sal,    case when sal<=2000 then ‘underpaid’ when sal>= 4000 then ‘underpaid’        else’ok'    End as statusfrom emp</=2000></code></pre><p>记录一下case函数的用法</p><pre><code>case when value then statement      else ’statement'end case;</code></pre><h3 id="2-把null值转换为实际值"><a href="#2-把null值转换为实际值" class="headerlink" title="2.把null值转换为实际值"></a>2.把null值转换为实际值</h3><p>有两个函数可以用<br>coalesce，返回的是参数列表里的第一个非null值。</p><p><code>select coalesce(comm,0) from emp;</code></p><p>或者用case函数</p><pre><code>select case         when comm is not null then comm        else 0         endFrom emp;</code></pre><h3 id="3-排序时对null值的处理"><a href="#3-排序时对null值的处理" class="headerlink" title="3.排序时对null值的处理"></a>3.排序时对null值的处理</h3><p>想把所有不为null的数放到排序的前面</p><pre><code>select ename,sal,comm    from(select ename,sal,comm,          case when comm is null then 0 else 1 end as is_null from emp)xorder by is_null desc, comm</code></pre><h3 id="4-union-和-union-all的区别"><a href="#4-union-和-union-all的区别" class="headerlink" title="4.union 和 union all的区别"></a>4.union 和 union all的区别</h3><p><em>union等同于针对union all的输出结果再执行一次distinct操作</em></p><h3 id="5-查询编号为10的部门的总工资和总奖金"><a href="#5-查询编号为10的部门的总工资和总奖金" class="headerlink" title="5.查询编号为10的部门的总工资和总奖金"></a>5.查询编号为10的部门的总工资和总奖金</h3><p>因为部分员工获得了不只一次奖金，所以这边有两种方法可以把重复项目给清除</p><p>一种是在聚合函数之前，用关键字distinct</p><p>另一种是，在进行连接查询之前执行聚合运算</p><pre><code>select deptno,        sum(distinct sal) as total_sal,        sum(bonus) as total_bonusfrom(    select e.empno,        e.ename,        e.sal,        e.deptno,        e.sal*case when eb.type = 1 then .1                    when eb.type =2 then .2                end as bonus    from emp e, emp_bonus eb    where e.empno = eb.empno and e.deptno = 10)x group by deptno;</code></pre><p><em>group by函数通常和聚合函数一起用，having的使用是因为，where不能和聚合函数（sum）一起使用</em></p><h3 id="6-上一题的拓展"><a href="#6-上一题的拓展" class="headerlink" title="6.上一题的拓展"></a>6.上一题的拓展</h3><p> 如果只是部分人获得了奖励，就需要left join，将没获得奖金的人的工资也算进来</p><h3 id="7-full-join是left-join和right-join的并集"><a href="#7-full-join是left-join和right-join的并集" class="headerlink" title="7.full join是left join和right join的并集"></a>7.full join是left join和right join的并集</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我最近找到的一本很棒的关于SQL的书，里面记录了150多个SQL常见问题和解决方法，最近做了挺久的sql优化，感觉自己还是蛮熟练的了，结果看到这本是真的被amaze了一下。复杂场景下，sql得会写才有机会优化吧，这本书追了追了。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MySQL" scheme="https://junshang11.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>关于索引</title>
    <link href="https://junshang11.com/2019/08/13/%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95/"/>
    <id>https://junshang11.com/2019/08/13/关于索引/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2019-09-15T07:11:42.378Z</updated>
    
    <content type="html"><![CDATA[<p>昨天碰到一个索引需要优化，翻了挺多资料，琢磨着得整一篇全的讲讲索引的知识点。</p> <a id="more"></a><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p> 我的理解就是书的目录，对数据进行定位和查找，速度极快。那既然是目录，问题就是，如果我数据更改的频次很高，比如说添加删除等，那这个目录就是得频繁的修改。这也是索引的特性，对于需要经常进行修改的表，我们并不添加索引。索引的添加语句是：</p><p> <code>CREATE UNIQUE INDEX index_name ON table_name (column_name) ;</code></p><h3 id="索引的种类"><a href="#索引的种类" class="headerlink" title="索引的种类"></a>索引的种类</h3><h4 id="从功能逻辑上来说"><a href="#从功能逻辑上来说" class="headerlink" title="从功能逻辑上来说"></a>从功能逻辑上来说</h4><p><em>普通索引</em>:没有任何约束,基础索引</p><p>_唯一索引_：在基础索引的基础上添加了数据唯一性的约束</p><p>_主键索引_：在唯一索引的基础上添加了不为空</p><p>_全文索引_：用的不多</p><p>（这种一步一步约束提升的样子有点像数据库设计三范式。。</p><h4 id="从物理实现上来分"><a href="#从物理实现上来分" class="headerlink" title="从物理实现上来分"></a>从物理实现上来分</h4><p>_聚集索引_：按照主键来排序存储数据</p><p>_非聚集索引_：会有单独的存储空间存放非聚集索引，这些索引项是按照顺序存储的，但索引项指向的内容是随机存储的，也就是说查询得分两步骤，先找到索引，再通过索引找到存储的数据。</p><p><strong>通常情况下，聚集索引比非聚集索引效率更高一点</strong></p><h4 id="按照字段个数划分"><a href="#按照字段个数划分" class="headerlink" title="按照字段个数划分"></a>按照字段个数划分</h4><p>_单一索引_：索引列为一列时</p><p>_联合索引_：索引列为多列时<br>创建联合索引的语句</p><p><code>create index 索引名 on 表名（字段名1，字段名2）</code></p><p>对于联合索引来说，有最左匹配原则。</p><h3 id="索引为啥默认采用b-树作为存储的数据结构"><a href="#索引为啥默认采用b-树作为存储的数据结构" class="headerlink" title="索引为啥默认采用b+树作为存储的数据结构"></a>索引为啥默认采用b+树作为存储的数据结构</h3><p>整理了一张图，很直接了。</p><p><img src="/images/%E7%B4%A2%E5%BC%95/b+%E6%A0%91.png" alt="索引数据结构"></p><h3 id="索引的使用原则"><a href="#索引的使用原则" class="headerlink" title="索引的使用原则"></a>索引的使用原则</h3><h4 id="啥时候创建索引呢"><a href="#啥时候创建索引呢" class="headerlink" title="啥时候创建索引呢"></a>啥时候创建索引呢</h4><ol><li>字段的数值有唯一性的限制</li><li>频繁作为 WHERE 查询条件的字段</li><li>需要经常 GROUP BY 和 ORDER BY 的列 </li><li>UPDATE、DELETE 的 WHERE 条件列，一般也需要创建索引</li><li>DISTINCT 字段需要创建索引</li></ol><h4 id="哪些情况下索引会失效"><a href="#哪些情况下索引会失效" class="headerlink" title="哪些情况下索引会失效"></a>哪些情况下索引会失效</h4><ol><li>如果索引进行了表达式计算，则会失效 </li><li>如果对索引使用函数，也会造成失效 （比如说我substring一下）</li><li>在 WHERE 子句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引，那么索引会失效</li><li>当我们使用 LIKE 进行模糊查询的时候，后面不能是 %（这边有个有意思的，%123不行，但是123%是能走索引的）</li><li>索引列与 NULL 或者 NOT NULL 进行判断的时候也会失效。</li><li>索引列与 NULL 或者 NOT NULL 进行判断的时候也会失效。（所以我们设计表的时候，最好都加上not null的约束）</li></ol><p>以上是我参考了SQL必知必会和一些csdn的blog总结的索引相关知识。总感觉对SQL这块，还得再写一篇关于SQL调优才行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天碰到一个索引需要优化，翻了挺多资料，琢磨着得整一篇全的讲讲索引的知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SQL" scheme="https://junshang11.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL必知必会学到的</title>
    <link href="https://junshang11.com/2019/07/13/SQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <id>https://junshang11.com/2019/07/13/SQL必知必会/</id>
    <published>2019-07-12T16:00:00.000Z</published>
    <updated>2019-09-05T10:02:36.893Z</updated>
    
    <content type="html"><![CDATA[<p>因为现在培训时期没有机会接触业务代码，所以就是做一些SQL优化的事情，然后遇到一些之前没有学过的SQL写法，比如说判断啊之类的，然后就买了“极客时间的SQL必知必会”的课，是真的不错，所以这边再开一篇，记录一下自己学到的新的写法。</p> <a id="more"></a><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>   utf8_general_ci 对大小写不敏感。 Utf8_bin是敏感的。</p><h3 id="2-设计数据库表的经典“三少一多”原则"><a href="#2-设计数据库表的经典“三少一多”原则" class="headerlink" title="2 设计数据库表的经典“三少一多”原则"></a>2 设计数据库表的经典“三少一多”原则</h3><ol><li>数据表个数越少越好</li><li>字段个数越少越好</li><li>联合主键字段个数越少越好</li><li>使用的主键和外键越多越好（提升相互之间的关联使用率）</li></ol><h3 id="3-查询常数"><a href="#3-查询常数" class="headerlink" title="3 查询常数"></a>3 查询常数</h3><p><code>Select ‘农药’ as platform, name from heroes;</code></p><h3 id="4-去重用的distinct，必须写在sql语句的最前面"><a href="#4-去重用的distinct，必须写在sql语句的最前面" class="headerlink" title="4 去重用的distinct，必须写在sql语句的最前面"></a>4 去重用的distinct，必须写在sql语句的最前面</h3><p><code>Select distinct name, age from users;</code></p><h3 id="5-百分比的表示"><a href="#5-百分比的表示" class="headerlink" title="5 百分比的表示"></a>5 百分比的表示</h3><p><code>Select concat(round(mp.max/mp.base,2)*100, ,’%');</code></p><h3 id="6-表创建相关"><a href="#6-表创建相关" class="headerlink" title="6 表创建相关"></a>6 表创建相关</h3><p>有时候为了防止删除关联表，就可以使用外键约束。<br><code>Set foreign_key_checks =1;</code><br>这样删除表的时候，就会报出 “a foreign key constraint fail”。</p><p>存储中文信息的时候，表头创建加一句<br><code>SET NAMES utf8mb4;</code><br>Utf8支持的最大字符长度是3个字节，所有4个字节的宽数据就存储不了，这时候就得改成utf8mb4</p><h3 id="7-where-和-having的区别"><a href="#7-where-和-having的区别" class="headerlink" title="7 where 和 having的区别"></a>7 where 和 having的区别</h3><p>where 是对数据的过滤，having是针对分组的</p><h3 id="8-子查询-any，all的用法"><a href="#8-子查询-any，all的用法" class="headerlink" title="8 子查询 any，all的用法"></a>8 子查询 any，all的用法</h3><p>select name, height from players where height &gt; any(select height from player where team_id = 1002);</p><h3 id="9-子查询什么时候用exists，什么时候用in"><a href="#9-子查询什么时候用exists，什么时候用in" class="headerlink" title="9 子查询什么时候用exists，什么时候用in"></a>9 子查询什么时候用exists，什么时候用in</h3><p>当查询字段进行了索引时，主表 A 大于从表 B，使用 IN 子查询效率更高；<br>相反主表 A 小于从表 B 时，使用 EXISTS 子查询效率更高。</p><p><strong>虽然是这么说，但是真的少用子查询好吧，因为效率真的不高</strong></p><h3 id="10-连接查询"><a href="#10-连接查询" class="headerlink" title="10 连接查询"></a>10 连接查询</h3><p>内连接<br>左外<br>右外<br>自连接</p><p>例子：三支球队比赛，列出所有的可能对阵表<br><code>Select t1.name, t2.name from team as t1 left join team as t2 on t1.id <> t2.id;</code></p><h3 id="11-视图"><a href="#11-视图" class="headerlink" title="11 视图"></a>11 视图</h3><pre><code>create view player_above_avg_height as Select player.id, height From player Where height > (select avg(height) from player)</code></pre><p>我查看了视图和临时表的区别，我还是挺好奇，视图在实际开发中，到底被用在哪里的。</p><h3 id="12-存储过程"><a href="#12-存储过程" class="headerlink" title="12 存储过程"></a>12 存储过程</h3><pre><code>CREATE PROCEDURE `add_num`(IN n INT)BEGINDECLARE i INT;DECLARE sum INT;SET i = 1;SET sum = 0;WHILE i <= n do set sum="sum" + i; i="i" +1; end while; select sum; < code></=></code></pre><p>NaviCat写法，如果在mysql命令行里面，得在两端加上DELIMITER // 结尾DELIMITER;。</p><p>存储过程的三种参数类型（in，out, inout)</p><pre><code>CREATE PROCEDURE `get_hero_scores`(OUT max_max_hp FLOAT,OUT min_max_mp FLOAT,OUT avg_max_attack FLOAT,s VARCHAR(255))BEGINSELECT MAX(hp_max), MIN(mp_max), AVG(attack_max) FROM heros WHERE role_main = s INTO max_max_hp, min_max_mp, avg_max_attack;END</code></pre><p>这边有个select… into的用法，将取到的值赋给out的数据，方便他传出来。</p><p>例题：</p><pre><code>CREATE PROCEDURE 'total_hp' ( OUT sum_hp_max FLOAT, IN s VARCHAR ( 255 ) ) BEGIN    SELECT        SUM( hp_max ) AS sum_hp_max     FROM        heros     WHERE        role_main = s INTO sum_hp_max;END CALL total_hp ( @sum_hp_max, '射手' );SELECT @sum_hp_max</code></pre><h3 id="13-事务隔离级别"><a href="#13-事务隔离级别" class="headerlink" title="13 事务隔离级别"></a>13 事务隔离级别</h3><pre>常见的错误*脏读：A读到了B没提交的事务**不可重复读：A两次查询得到两个不同的结尾**幻读：A第一次读和第二次读获得的数据不一（B事务对数据做出了修改）*</pre><p>四种隔离级别：<br><img src="/images/isolation_level.jpg" alt="四种隔离级别" title="四种隔离级别"></p><p>MySQL是不可重复读。</p><h3 id="14-游标"><a href="#14-游标" class="headerlink" title="14 游标"></a>14 游标</h3><p>游标实际上是一种控制数据集的更加灵活的处理方式。<br>DECLARE cursor_name CURSOR FOR select_statement;</p><p>例子：</p><pre><code>DECLARE cur_hero CURSOR FOR SELECT hp_max FROM heros;OPEN cursor_name;FETCH cursor_name INTO var_name;CLOSE cursor_name;DEALLOCATE PREPARE;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为现在培训时期没有机会接触业务代码，所以就是做一些SQL优化的事情，然后遇到一些之前没有学过的SQL写法，比如说判断啊之类的，然后就买了“极客时间的SQL必知必会”的课，是真的不错，所以这边再开一篇，记录一下自己学到的新的写法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SQL" scheme="https://junshang11.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL Cheatsheet</title>
    <link href="https://junshang11.com/2019/03/13/SQL%20Cheatsheet/"/>
    <id>https://junshang11.com/2019/03/13/SQL Cheatsheet/</id>
    <published>2019-03-12T16:00:00.000Z</published>
    <updated>2019-09-05T12:48:04.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL语句集合"><a href="#SQL语句集合" class="headerlink" title="SQL语句集合"></a>SQL语句集合</h3><p>这篇是用来记录我之前忘记的好多SQL语句的，因为有些SQL语句真的是不常用就会忘记的，记到这边来下次写SQL的时候可以看。</p> <a id="more"></a><h3 id="皮一下"><a href="#皮一下" class="headerlink" title="皮一下"></a>皮一下</h3><p>开篇先来皮一下，因为真的好几次忘记了自己的密码是什么，然后去网上找那些改密码的方法。所以干脆这边就记录一下。</p><p>先把MySQL服务关闭。</p><p><code>sudo /usr/local/mysql/support-files/mysql.server stop</code></p><p>然后进入mysql的bin目录。<code>cd /usr/local/mysql/bin</code>。</p><p>绕过用户验证。<code>mysqld --skip-grant-tables</code></p><p>重新开一个命令行，直接进mysql。</p><p><code>set password for 'root'@'localhost'=password('xxx');</code></p><p>这样子新的密码就修改好了。如果你需要修改原来的老密码，用的是</p><p><code>update user set password=password('123456') where user='root';</code></p><h3 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h3><p>创建数据库的</p><pre><code>DROP TABLE IF EXISTS admin;CREATE TABLE admin (  username varchar(20) NOT NULL DEFAULT '',  password varchar(32) DEFAULT NULL,  PRIMARY KEY ('username')) ENGINE=InnoDB DEFAULT CHARSET=utf8;</code></pre><p>创建表的</p><pre><code>DROP TABLE IF EXISTS t_stu;CREATE Table t_stu(        stuId int(11) NOT NULL AUTO_INCREMENT,          stuName varchar(20) NOT NULL,          PRIMARY KEY(stuId) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</code></pre><p>修改表的（增加，删除列）</p><p><code>ALTER TABLE t_student ADD col char(20);</code></p><p><code>ALTER TABLE 't_student' DROP COLUMN col;</code></p><p>删除表</p><p><code>DROP TABLE table;</code></p><h4 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h4><p>插入</p><p><code>INSERT INTO table (col1,col2) VALUES(val1,val2); </code></p><p>插入检索出来的数据</p><pre><code>INSERT INTO table(col1,col2) SELECT * FROM table2;</code></pre><p>更新语句</p><pre><code>UPDATE table1SET col = valWHERE id = 1;</code></pre><p>删除语句</p><pre><code>DELETE FROM table WHERE id =1;</code></pre><p>清空表</p><p><code>TRUNCATE TABLE table； </code></p><p><em>TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。</em></p><p>查询语句实在是有点多，一些常用的我不会忘的就不记了，写点我容易忘的</p><p>通配符的用法</p><pre><code>SELECT * FROM tableWHERE col LIKE '[^AB]%';-- ^否定，[]集合，匹配其中之一，%匹配多个字符，_匹配一个字符</code></pre><p>连接字段</p><pre><code>SELECT CONCAT(TRIM(col),'('TRIM(col2),')')FROM student;</code></pre><p>日期计算记一个日期之差的把</p><p><code>SELECT DATEDIFF('2007-12-31','2007-12-30'); </code></p><p>接下来就是比较难的部分了：</p><p><strong>分组是将具有相同的数据值的行放在同一组中</strong></p><pre><code>SELECT col, COUNT(*) AS numFROM tableGROUP BY col</code></pre><p><em>这里记一下，where是过滤行的，having是过滤分组的，group by默认出现在where之后，order by之前</em></p><p>子查询就不记了吧，因为效率是真的低，一般来说子查询都能用连接查询替代，所以接下来用一张神图来概括所有的连接查询。</p><p><img src="/images/sql_join.jpg" alt="join神图" title="连接的写法"></p><p>大概常用的就是这些了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SQL语句集合&quot;&gt;&lt;a href=&quot;#SQL语句集合&quot; class=&quot;headerlink&quot; title=&quot;SQL语句集合&quot;&gt;&lt;/a&gt;SQL语句集合&lt;/h3&gt;&lt;p&gt;这篇是用来记录我之前忘记的好多SQL语句的，因为有些SQL语句真的是不常用就会忘记的，记到这边来下次写SQL的时候可以看。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SQL" scheme="https://junshang11.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令相关</title>
    <link href="https://junshang11.com/2019/03/10/Linux%E8%AF%AD%E5%8F%A5%E7%9B%B8%E5%85%B3/"/>
    <id>https://junshang11.com/2019/03/10/Linux语句相关/</id>
    <published>2019-03-09T16:00:00.000Z</published>
    <updated>2019-09-17T09:33:18.972Z</updated>
    
    <content type="html"><![CDATA[<p>因为我一直用的是Mac OS，这是一个类Unix的系统，然后之前大一大二写Python的时候，有一本<learn python the hard way>里面，单独分了一章出来讲命令行语句，所以基础cd，mkdir，touch我也知道，写这个是因为我看到明天有个校招的公司要求有Linux基础，我这边抱个佛脚，记录一些使用频率高点的其他的命令。</learn></p><a id="more"></a><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><p>直接上来就是帮助，有时候假如我一个命令忘记了就直接用man + 命令去查看，比如我man ps，就能看到process status的详细信息。</p><p>但如果只想看简洁版的，就用–help。</p><h3 id="Vim相关"><a href="#Vim相关" class="headerlink" title="Vim相关"></a>Vim相关</h3><p>之前学的时候我是挺讨厌vim的，可能我没到那个级别，用vim修改python路径或者java路径的时候，总是不会用，后来用的多了感觉也还行。</p><p>vim分三个模式：</p><p><em>一般指令模式</em> ：默认模式，可以查看内容</p><p><em>编辑模式</em> ：按i进入，退出按esc</p><p>_指令列模式_： 按下：进入，保存，退出等操作。</p><p>一般的指令模式有:</p><pre>:w 写磁盘；:w! 强制写磁盘:q 退出:q! 强制退出不保存:wq 写入磁盘后离开:wq! 强制写入磁盘后离开</pre><h3 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h3><p>ls,cd,mkdir,cp,rm这些我熟悉就不写了吧，写个我自己老是忘的:</p><p><code>touch [-acdmt] filename</code></p><pre>这里面的常用的参数含义是：-a:更新-c:文件不存在就创建新文件-m: 更新</pre><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p><code>chmod [-R] xyz dirname/filename</code></p><p>好像是计算机组成原理的时候学过，r:4,w:2,x:1</p><p>这边的xyz指的是三组人群，owner，同组用户，其他用户</p><p>也可以用符号来设定权限：</p><pre># chmod [ugoa][+-=] [rwx] dirname/filename- u：拥有者- g：所属群组- o：其他人- a：所有人- +：添加权限- -：移除权限- =：设定权限</pre><h3 id="获取文件内容"><a href="#获取文件内容" class="headerlink" title="获取文件内容"></a>获取文件内容</h3><pre>cat:取得文件内容tac：cat的反向操作，从最后一行开始打印more：可以一页一页地查看文件内容less：和more差不多，但有个向前翻页的功能</pre><h3 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h3><p>记一个常用的gzip吧</p><pre>gzip [-cdtv#] filename-c ：将压缩的数据输出到屏幕上-d ：解压缩-t ：检验压缩文件是否出错-v ：显示压缩比等信息-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6</pre><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>这块应该是我看到的最多的面试题目。</p><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>全称是process status ，查看某个时间点的进程信息的</p><p>ps -I  :查看自己的进程</p><p>ps aux 查看系统所有进程</p><p>ps aux | grep threadx 查看特定进程</p><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>实时显示进程信息</p><p>top -d 2</p><h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><p>查看所有进程树</p><p>Pstree -A</p><p>讲真。。主要一般开发都在unix这边，这个不练是真的记不住。我去装个虚拟机跑centos吧。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为我一直用的是Mac OS，这是一个类Unix的系统，然后之前大一大二写Python的时候，有一本&lt;learn python the hard way&gt;里面，单独分了一章出来讲命令行语句，所以基础cd，mkdir，touch我也知道，写这个是因为我看到明天有个校招的公司要求有Linux基础，我这边抱个佛脚，记录一些使用频率高点的其他的命令。&lt;/learn&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="https://junshang11.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>json的那些事</title>
    <link href="https://junshang11.com/2019/02/20/json%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>https://junshang11.com/2019/02/20/json的解析/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-09-17T23:32:47.919Z</updated>
    
    <content type="html"><![CDATA[<p>前几天写了Ajax相关的知识，然后这几天写前后端传json磕磕绊绊中学到了点新的，这边来记录一下。</p><a id="more"></a><h3 id="页面发Ajax请求过来，我怎么收"><a href="#页面发Ajax请求过来，我怎么收" class="headerlink" title="页面发Ajax请求过来，我怎么收"></a>页面发Ajax请求过来，我怎么收</h3><pre><code>$(function(){// 绑定点击事件 $("#btn").click(function(){        $.ajax({         url:"user/testJson",         contentType:"application/json;        charset=UTF-8",         data:'{"addressName":"aa","addressNum":100}',         dataType:"json",        type:"post",         success:function(data){         alert(data);         alert(data.addressName); }});});});</code></pre>现在传过来一个键值对对象，我这边就得在我的控制器参数里面加上@RequestBody注解<pre><code>@RequestMapping("/testJson") public void testJson(@RequestBody Address address) { System.out.println(body); }</code></pre><p>这边的@RequestBody会自动地将json数据转化成java bean对象。</p><h3 id="将JavaBean对象转成json"><a href="#将JavaBean对象转成json" class="headerlink" title="将JavaBean对象转成json"></a>将JavaBean对象转成json</h3><p>比如说我现在服务器查到了信息，需要将数据返回给前端</p><pre><code><pre><code>@RequestMapping("/testJson") public @ResponseBody Address testJson(@RequestBody Address address) {     address.setAddressName("上海");    return address;}</code></pre><p>只需要在返回值前面加上@ResponseBody就行了，这样他会自动解析bean对象转成json。</p><h3 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h3><p>当然上面的操作没有一个第三方包的支持是不可能的，@RequestBody和@ResponseBody都没有内置json的解析器。</p><p>我看的绝大多数教程用的都是jackson去解析json，然后我看到一篇比较近期很流行的json解析器排行时，看到了谷歌开源的Gson。相比阿里出品的FastJson，他有更好的稳定性，所以这边讲一下Gson的用法。</p><h4 id="首先是Gson的实力化"><a href="#首先是Gson的实力化" class="headerlink" title="首先是Gson的实力化"></a>首先是Gson的实力化</h4><p><code>Gson gson = new Gson();</code></p><p>我们可以通过GsonBuilder对Gson进行个性化的配置：</p><pre><code>gson = new GsonBuilder()                    .setLenient()// json宽松                    .enableComplexMapKeySerialization()//支持Map的key为复杂对象的形式                    .serializeNulls() //智能null                    .setPrettyPrinting()// 调教格式                    .disableHtmlEscaping() //默认是GSON把HTML 转义的                    .create();</code></pre><h4 id="各种数据和json之前的转化"><a href="#各种数据和json之前的转化" class="headerlink" title="各种数据和json之前的转化"></a>各种数据和json之前的转化</h4><h5 id="JavaBean转json"><a href="#JavaBean转json" class="headerlink" title="JavaBean转json"></a>JavaBean转json</h5><p><code>        String jsonStr = gson.toJson(student);</code></p><h5 id="List和Map-转json"><a href="#List和Map-转json" class="headerlink" title="List和Map 转json"></a>List和Map 转json</h5><pre><code> List<string> list = Arrays.asList("1", "a", "3", "rt", "5");String jsonStr = gson.toJson(list);</string></code></pre><pre><code>          Map<string, object> content = new HashMap<string, object>();        content.put("name", "ericshang11");        content.put("age", "11");        String jsonStr = gson.toJson(content);</string,></string,></code></pre><h5 id="json转其他数据类型"><a href="#json转其他数据类型" class="headerlink" title="json转其他数据类型"></a>json转其他数据类型</h5><p>先看一个json转成JavaBean的：</p><pre><code>String studentJsonStr="{\"name\":\"ericshang11\",\"age\":11}";Student student1 = gson.fromJson(studentJsonStr, Student.class);</code></pre><p>这边用到了一个fromJson方法，他的第一个参数值是需要转的json对象，第二个是要转成的类型。但是当我们不明确要转成的对象是什么的时候呢，我们就可以用Gson提供的TypeToken，这是一个数据类型转换器。</p><p><code>List<person> ps = gson.fromJson(str, new TypeToken<list<person>>(){}.getType());<br></list<person></person></code></p><p>以上就是我整理json相关的知识，能应付我绝大多数开发场景了吧。</p></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天写了Ajax相关的知识，然后这几天写前后端传json磕磕绊绊中学到了点新的，这边来记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="json" scheme="https://junshang11.com/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="https://junshang11.com/2019/02/16/Ajax/"/>
    <id>https://junshang11.com/2019/02/16/Ajax/</id>
    <published>2019-02-15T16:00:00.000Z</published>
    <updated>2019-09-17T01:37:25.852Z</updated>
    
    <content type="html"><![CDATA[<p>之前学Java Web的时候学过Ajax，当时得创建XMLHttpRequest，然后通过这个XHR去和服务端进行交互。最近写毕设的时候想通过Ajax实现点击按钮，弹出对话框（用css3的z index实现），然后对数值进行修改，点击确定post到服务器的操作。然后现在就不用js原生的那种方法实现，用jQuery封装的Ajax来实现。</p><a id="more"></a><h3 id="配置和通常情况下的写法"><a href="#配置和通常情况下的写法" class="headerlink" title="配置和通常情况下的写法"></a>配置和通常情况下的写法</h3><p>第一步就是引入jQuery的文件。可以从bootcdn上找到link。</p><p>比如说页面上我有一个修改按钮，那我再head里的js代码如下：</p><pre><code>$("button").click(function(){    $.ajax({url:"emp/edit",    data:""    type:"GET",        success:function(result){       //假如请求成功，执行的方法是    },    error:function(result){    //假如访问失败，执行的方法    }});});</code></pre><p>然后还有一种场景是在一个js方法里，调用了ajax去向服务器发出请求，写法是：</p><pre><code>function doPost(args){    $.ajax({                url:"emp/depts",                type:"GET",                success:function(result){                do something                }})};</code></pre><p>以上两种是通常情况下的ajax使用场景。</p><p>对于我来说，一定要注意到括号的开闭啊，真的是好多次报错就是因为括号没有合理地开闭。</p><h3 id="带参数解析"><a href="#带参数解析" class="headerlink" title="带参数解析"></a>带参数解析</h3><p>接下来，说一下，ajax请求里的这些常用的参数是什么意思。</p><p><em>url</em> : </p><p>String类型的参数，请求的地址。</p><p>_type_：</p><p>请求的方法，通常情况下是post或者是get，这边正好再回顾一下http的get和post方法。</p><pre>GET 从指定的资源请求数据；post 向指定的资源提交要处理的数据。其中相同的点在于，都可以从服务器取得数据，但GET可能会拿到缓存数据，但post拿到了也不会缓存数据。</pre><p><em>data</em> :</p><p>提交到服务器的数据，一般是字符串类型；如果是对象类型，那就转成键值对的形式。比如这个样子：</p><pre><code>data: {                "userName": $('#userName').val(),                "password": $('#password').val(),            },</code></pre><p>dataType_:</p><p>预期的服务器的返回类型是啥：通常情况下有xml，text，json，但json一般来说是主流吧，明天再写一篇讲如何用Gson去解析服务器传过来的json数据的。</p><p><em>success</em> 和 <em>error</em></p><p>要求为Function类型的参数，记录的是请求成功或者失败后的回调函数。</p><p>一般使用的就是这几个参数。</p><h3 id="用到的其他的一些jQuery函数和方法"><a href="#用到的其他的一些jQuery函数和方法" class="headerlink" title="用到的其他的一些jQuery函数和方法"></a>用到的其他的一些jQuery函数和方法</h3><p>写到一个批量删除数据的时候，用到一个each函数，这边记录一下ajax each函数的用法。</p><pre><code>$.each( object, callback )</code></pre><p>这边object是遍历的对象，数组或者是元素；</p><p>callback是用于循环执行的函数。</p><p>另外还有一个prop方法这边记录一下。</p><p>prop() 方法设置或返回被选元素的属性和值。</p><p>当该方法用于<strong>返回</strong>属性值时，则返回第一个匹配元素的值。</p><p><code>$(<em>selector</em>).prop(<em>property</em>)</code></p><p>当该方法用于<strong>设置</strong>属性值时，则为匹配元素集合设置一个或多个属性/值对。</p><p><code>$(<em>selector</em>).prop(<em>property,value</em>)</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前学Java Web的时候学过Ajax，当时得创建XMLHttpRequest，然后通过这个XHR去和服务端进行交互。最近写毕设的时候想通过Ajax实现点击按钮，弹出对话框（用css3的z index实现），然后对数值进行修改，点击确定post到服务器的操作。然后现在就不用js原生的那种方法实现，用jQuery封装的Ajax来实现。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Ajax" scheme="https://junshang11.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>uml相关的元素在这边啊</title>
    <link href="https://junshang11.com/2019/02/12/uml/"/>
    <id>https://junshang11.com/2019/02/12/uml/</id>
    <published>2019-02-11T16:00:00.000Z</published>
    <updated>2019-09-07T12:22:53.543Z</updated>
    
    <content type="html"><![CDATA[<p>  最近看一些常用设计模式的时候，老是看到uml图，软件工程的课上学过，学完就忘了，没想到设计模式里到处都是，这里贴一张在UML Diagram上面找到的一张图，是关于uml的常用元素的。</p><a id="more"></a><p><img src="/images/uml.png" alt="uml常用元素"></p><p>然后这边再记录一点对象之间的关系，虽然图上已经有标注了，但怕自己有时候会脑抽弄错吧。</p><h3 id="对象之间的关系"><a href="#对象之间的关系" class="headerlink" title="对象之间的关系"></a>对象之间的关系</h3><h4 id="泛化关系-Generalization-空心箭头线"><a href="#泛化关系-Generalization-空心箭头线" class="headerlink" title="泛化关系 Generalization   空心箭头线"></a>泛化关系 Generalization   空心箭头线</h4><p>is-a的关系，比如说，动物和狗，狗 is-a 动物，所以是泛化关系，用的箭头是空心箭头！</p><h4 id="实现关系-Realization-实心箭头的虚线"><a href="#实现关系-Realization-实心箭头的虚线" class="headerlink" title="实现关系 Realization   实心箭头的虚线"></a>实现关系 Realization   实心箭头的虚线</h4><p>实心箭头的虚线表示的，就是类与接口的关系。</p><h4 id="关联关系-Association-就直线"><a href="#关联关系-Association-就直线" class="headerlink" title="关联关系 Association    就直线"></a>关联关系 Association    就直线</h4><p>一条直线表示</p><h4 id="聚合关系-Aggregation-带空心菱形的实线"><a href="#聚合关系-Aggregation-带空心菱形的实线" class="headerlink" title="聚合关系 Aggregation   带空心菱形的实线"></a>聚合关系 Aggregation   带空心菱形的实线</h4><p>是整体和部分的关系，比如说汽车和轮胎，方向盘这些零部件。图例用带空心菱形的实线表示，菱形指向的是实体。</p><h4 id="组合关系-Composition-带实心的菱形"><a href="#组合关系-Composition-带实心的菱形" class="headerlink" title="组合关系 Composition    带实心的菱形"></a>组合关系 Composition    带实心的菱形</h4><p>也是整体和部分的关系，但是和聚合关系不同的是，部分不能够独立存在，这边的经典例子是公司和部门，要是没有公司，部门的存在没啥意义。图例是用带实心的菱形表示。</p><h4 id="依赖关系-Dependency-带箭头的虚线"><a href="#依赖关系-Dependency-带箭头的虚线" class="headerlink" title="依赖关系 Dependency    带箭头的虚线"></a>依赖关系 Dependency    带箭头的虚线</h4><p>是一种使用的关系，一个类需要另一个类的协助。</p><p>我感觉也不需要刻意去背吧，以后要画了要看了，翻出这篇来看一下就好了，所以在这边mark一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  最近看一些常用设计模式的时候，老是看到uml图，软件工程的课上学过，学完就忘了，没想到设计模式里到处都是，这里贴一张在UML Diagram上面找到的一张图，是关于uml的常用元素的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="uml" scheme="https://junshang11.com/tags/uml/"/>
    
  </entry>
  
  <entry>
    <title>PageHelper的使用</title>
    <link href="https://junshang11.com/2019/02/09/%E5%88%86%E9%A1%B5/"/>
    <id>https://junshang11.com/2019/02/09/分页/</id>
    <published>2019-02-08T16:00:00.000Z</published>
    <updated>2019-09-15T02:15:53.098Z</updated>
    
    <content type="html"><![CDATA[<p>之前写网页写到分页的时候都很头疼，因为涉及的数据太多了，分页的信息得封装到一个类里面，页面信息又得分装到一个类里面，很麻烦，所以这边尝试着用Github 开源的MyBatis PageHelper做一次。</p> <a id="more"></a><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>那第一步还是加载依赖，</p><p><img src="/images/%E5%88%86%E9%A1%B5/1.png" alt="依赖"></p><p>接着在MyBatis全局配置文件中配置拦截器插件。<br><img src="/images/%E5%88%86%E9%A1%B5/2.png" alt="拦截器插件"><br>拦截器的具体实现这边先不多花时间进行关注，我们去看一下使用流程。</p><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><p>首先我们需要</p><pre><code>//获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);//紧跟着的第一个select方法会被分页List<employee> list = employeeService.getAll();//使用pageinfo包装,传入连续显示的页数，这个5是相邻页码的意思PageInfo pageInfo = new PageInfo(list,5);//接下来我们就可以用model以键值对的形式将值传出去了model.addAttribute("pageInfo",pageInfo);</employee></code></pre><h3 id="看一下神奇的PageInfo"><a href="#看一下神奇的PageInfo" class="headerlink" title="看一下神奇的PageInfo"></a>看一下神奇的PageInfo</h3><p><img src="/images/%E5%88%86%E9%A1%B5/3.png" alt="PageInfo"><br>这边事实上就是对分页的相关信息进行了一个封装，可以看到封装的数据很全面，这样对前端代码的编写带来了极大的便利。</p><p><img src="/images/%E5%88%86%E9%A1%B5/4.png" alt="前端代码展示"></p><p>然后这边记录一下前端的相邻页码的写法。挺有意思的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看到PageHelper实现的思想其实是一个更大的封装。不仅将分页信息封装起来，还将页面的详细信息封装起来。挺方便的。并且根据文档，他的实现还是很安全的。</p><blockquote><p>只要你可以保证在 PageHelper 方法调用后紧跟 MyBatis 查询方法，这就是安全的。因为 PageHelper 在 finally 代码段中自动清除了 ThreadLocal 存储的对象。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写网页写到分页的时候都很头疼，因为涉及的数据太多了，分页的信息得封装到一个类里面，页面信息又得分装到一个类里面，很麻烦，所以这边尝试着用Github 开源的MyBatis PageHelper做一次。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SSM" scheme="https://junshang11.com/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis Generator的使用</title>
    <link href="https://junshang11.com/2019/02/03/ssm/"/>
    <id>https://junshang11.com/2019/02/03/ssm/</id>
    <published>2019-02-02T16:00:00.000Z</published>
    <updated>2019-09-14T13:23:55.432Z</updated>
    
    <content type="html"><![CDATA[<p>之前学SSM的时候，因为时间不多，所以有一些不是核心的知识点我就直接跳过了，比如说MyBatis的逆向工程，也就是Mybatis Generator的使用，我就没有去管。然而事实上，自己写的那个接口的映射文件总写的很繁杂，在复杂的业务上，那写的叫一个长。据说Mybatis Generator创建的是非常标准化的映射写法，所以这次来学习一下。</p> <a id="more"></a><h3 id="Maven中加入依赖并配置插件信息"><a href="#Maven中加入依赖并配置插件信息" class="headerlink" title="Maven中加入依赖并配置插件信息"></a>Maven中加入依赖并配置插件信息</h3><p>那第一步肯定是在maven中加入依赖。</p><p><img src="/images/generator/1.png" alt="依赖"></p><p>然后因为使用的是idea，所以我们用idea plugin的形式来配置generator的相关信息。</p><p><img src="/images/generator/2.png" alt="插件信息"></p><p>我这边踩过的坑是啥呢，没加mysql-connector，插件是不会调用上面的dependency里的mysql-connector的，所以要额外配一个，然后我一开始不清楚要写configurationFile，现在看来是蛮蠢的，你不写配置文件的话，用的应该是默认的那种，默认的文档结构和我自己需要的应该是不一样的，所以我们这边自己配置一个路径地址，自己也好找。</p><h3 id="接下来就是写运行的配置信息"><a href="#接下来就是写运行的配置信息" class="headerlink" title="接下来就是写运行的配置信息"></a>接下来就是写运行的配置信息</h3><p>这边包括了，你想把创建的pojo啊，mapper接口和mapper映射文件放在哪里，直接上代码,我注释的挺全的。</p><p><img src="/images/generator/3.png" alt="配置1"><br><img src="/images/generator/4.png" alt="配置2"></p><p>然后这边我遇到一个问题呢，是idea带来的，我本来想把mapper映射文件和mapper接口放在一起，但idea的思想是，你的xml就应该和resources放在一起读取。那不违背这个原则，我就在resources里面创建了新的directory，和我mapper接口的路径保持一致，这样就能一一对应起来。</p><p>这些配置做完以后，MyBatis Generator就会把你在MySQL数据库的数据，标准化地配置出来。</p><h3 id="看一下他生成的接口映射文件"><a href="#看一下他生成的接口映射文件" class="headerlink" title="看一下他生成的接口映射文件"></a>看一下他生成的接口映射文件</h3><p>pojo和mapper接口是不用看了，可以看到是相当的全，我更在意地是他的mapper接口映射文件。<br>可以看到他把一些需要重复使用的sql语句，给归并了，抽出来放在了表头的sql里，这样子看下面的某个业务需要使用到这些，只需要include refid就行，这种模块化的思想，让代码的可读性提高了很多。</p><p>以上是我从MyBatis Generator里学到的新的东西，当然，他生成的接口不可能是完全符合我们的业务需求的，所以如果我们有一对多或者多对一的需求，我们可以自己扩充，然后这边记得，Mybatis的一对一的关键词是association，一对多是collection，我自己记反了，结果2个小时就这么没了。。。真的头疼。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前学SSM的时候，因为时间不多，所以有一些不是核心的知识点我就直接跳过了，比如说MyBatis的逆向工程，也就是Mybatis Generator的使用，我就没有去管。然而事实上，自己写的那个接口的映射文件总写的很繁杂，在复杂的业务上，那写的叫一个长。据说Mybatis Generator创建的是非常标准化的映射写法，所以这次来学习一下。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://junshang11.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="SSM" scheme="https://junshang11.com/tags/SSM/"/>
    
  </entry>
  
</feed>
